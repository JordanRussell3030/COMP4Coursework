\chapter{System Maintenance}

\section{Environment}

\subsection{Software}

I used the following software to produce my system:

\begin{itemize}
	\item Python 3.4
	\item Python IDLE
	\item PyQt4 (Contains some HTML elements)
	\item SQLite3
	\item Internet Explorer
\end{itemize}

\subsection{Usage Explanation}

\textbf{Python 3.4: }

Python 3.4 was the most up to date release of Python when I began the implementation of the system, and I continued to use it throughout, despite 3.5 being released, to avoid any incompatibilities with the other software used. I use this language because it is the language I used to learn the fundamentals of prorgamming and therefore the one I am most familiar with. 

\textbf{Python IDLE: }

Python IDLE is the environment which Python uses, and which I am most familiar with.

\textbf{PyQt4: }

PyQt4 is Qt, a separate GUI language, altered to work with Python in order to create a clear, smoothly operating graphical interface, and was also used to change the colours and sizes of widgets in the system. Some elements of HTML are in Qt which allows for colour changing and size adjusting.

\textbf{SQLite3: }

SQLite3 is included in the Python 3.4 software download package by default, and is useful for creating a very effective database structure which can be easily accessed and modified uisng Python and PyQt code. 

\textbf{Internet Explorer: }

I used IE to look online to find out how to use code which I had not used before and which wasn't fundamental to learn for my A-Level course, such as how to use PyQt4 to change the sizes and colours of widgets.

\subsection{Features Used}

\textbf{Python 3.4: }

Python 3.4 allowed me to write my code and be able to test it, even in a GUI form when that point was reached. 

\textbf{Python IDLE: }

Python 3.4 comes with an IDLE environment which can be used to easily and frequently test my system as it is created; it allows you to view the system as it would look following distribution, with the IDLE window being used for inputs and outputting errors, which is very useful for fixing said errors. It also has a very clear colour-coded scheme for the code, making it easier to find segments of code.

\textbf{PyQt4: }

PyQt4 comes with many pre-coded tools which I could use to implement a graphical use interface; I was able to create classes which were derived from pre-coded files in the software package, such as buttons and windows. It also gave me limited HTML capabilities with which I could change the look of the GUI.

\textbf{SQLite3: }

SQLite3 was already part of the Python 3.4 package and provided effective SQL capabilities which I used to write data to a structured database and retrieve data ready to be output to the user.

\textbf{Internet Explorer: }

Wasn't a part of the implementation, was only used to research code which I could use. Provided useful access to StackOverflow.

\section{System Overview}

\subsection{Graphical User Interface}

The GUI provides a navigation tool for the user to use to navigate the different parts of the system in a friendly and easy to use way. Buttons are used to connect the screens and make it easy to access them by simply clicking them. Line edits, combo boxes and other buttons are used for a variation of input methods, which have been enlarged to give the system a more commercial look. Text boxes and images are used to provide an output which makes it clear that the system is intended for educational purposes. The interface also has clear titles so the user will always know where they are in the system.

\subsection{Navigation of Windows}

The windows have been structured in such a way that it is necessary to understand how each of them are connected; The welcome screen and home screen are in a stack so that the welcome screen will not be accessible once the user is already in the system. The menus are all connected individually using subclassed buttons and methods, to ensure that each window can be accessed from at least one of the previous menus, but only from one. The lessons and homeworks are in stacks so that the user cannot have only one screen of a homework open at one time, and the user's inputs on each screen will be kept there until the entire stack is closed, should they decide to go back to something. There is a home screen, which connects to two topic menus, which connect to five specific menus each, which each connect to two, three or six lessons or homeworks, like a branch system. The connections which share a menu are all in the same file to make them easier to find.

\subsection{Viewing a Lesson}

Each lesson is accessed from a derived lesson menu, all of which are in the same file (so all lesson connections are also in the same file), and each lesson consists of two pages in a stack together, both of which are subclassed from separate 'page 1' and 'page 2' parent classes. There are buttons which can allow the user to easily cancel the lesson and return to the menu, continue to the next screen, and close the window when they are done. There is one line edit with a simple test question in each 'page 2', but this isn't recorded in the database. The line edit answer can be checked by clicking the check answer button, and an algorithm is run which will tell the user whether or not they are correct by checking the user's input against the hard-coded answer in the sub-class. This algorithm is in the lesson 'page 2' parent class.

\subsection{Completing a Homework}

The homeworks are accessed in exactly the same way as the lessons, except they are branched from the homework button on the home screen, and use different connections in the following menus. Again, there are buttons for easy navigation, although the homework widgets also have more line edits, combo boxes and multiple choice buttons for inputting answers, the scores from which are saved to the database. Each answer is checked using individual algorithms which are in the parent homework 'page 1' and 'page 2' classes. These algorithms essentially do the same thing, just working with different input types. They check the user's input against the hard-coded answers in the sub-classes, and give error messages if the user is wrong, until they run out of attempts, which decrement with every wrong answer as part of the algorithm. Once a question is either correct, or the user has run out of attempts, the algorithm will disable the input widegts as appropriate to prevent the user having too many goes or saving to the database twice and entering a loop or other error.

\subsection{Storing in the Database}

The database methods are all ina separate class, which can be accessed by all of the other files when needed. For example, when a homework score needs to be saved the file with the homework in it will be able to access the database class and the appropriate method, and pass through the variables from the homework into the SQL insert statements. The only times the database is written to is when the user completes a homework; the task name and first question score is saved after clicking next to the second page, and the scores for the second, third and fourth questions are saved after clicking finish. If the task has been done before and the new scores are better, they will over-write the old ones. The update statements are separate for each question score so that they don't all have to be better for one to over-write. The database is accessed for output when the user loads the progress viewer or the report widget; all information based on the corresponding query is fetched and displayed in the QTableWidgets.

\subsection{Viewing the Database Information}

There are two ways for the user to view information stored in the database in the system: The progress window, accessible from the home screen, and the report window, accessible from the progress screen, both of which use QTableWidgets to display the information. The progress screen just displays all data in the database in the format you would expect; each piece of data is under the right column and in the right row. The report screen begins blank and is filled with all information relevant to the query which can be made by the user to search for specific task names or scores, using combo boxes for input. SQL statements are used to search for the relevant data, which is fetched, and organised in the table widget using iteration.

\subsection{The Task Data}

The task data is obtained by clicking the next button on any first homework page, and the hard-coded task name variable in the sub-class will be recorded to the database. Once it is saved once, it will never change or disappear, as there is no need. All task names will appear under the Task Name column in the qtablewidgets.

\subsection{The Score Data}

The score for the first question of any homework will be calculated using the algorithms and then saved to the database with the task name when next is clicked. Clicking next will also save the values 0 to the other 3 question's spaces in the database. Update statements are used so that whenever finish is clicked on the second page, the scores will be over-written whether they are 0's, or if the task has been done before, values less than the new score.

\section{Code Structure}

\subsection{Database Controller Class}

\begin{python}
class Database:
    def __init__(self, db_name):
        self._db_name = db_name
        self.table_name = "Student"
        self.create_table(self.table_name)
\end{python}

This class contains all of the database manipulating code for the system. It can be accessed by any file using the global database variable which can be called from methods which need it, making it easier to keep all SQL code and PyQt code separate. db\_name is the name of the variable which represents the database which is called at the bottom of the file; each method can be called to change this database variable and the variables which change it are passed through from the subclasses in other files, which is efficient as most of the files are subclassed so there will be no collisions between data. The table name is hard-coded so it will never change and the system will always be able to search for the same name to check if the database exists when it is run. The create\_table method is then run, which either creates a new table, leaves the old one or replaces the old one.

\subsubsection{execute\_sql method}

\begin{python}
def execute_sql(self, sql):
     with sqlite3.connect(self._db_name) as db:
         cursor = db.cursor()
         cursor.execute(sql)
\end{python}

This method is called every time an SQL statement is executed in the other methods in this class. It connects to the database using the name which is passed through from the global variable, which will always be the same as it is hard-coded; this connection is only needed to be written once as every SQL statement will be executed following this connection being made in this method. Then the cursor, which is the control structure, is also always in this method so is not need in the others. Then the SQL statement, which is passed through from the method which is calling the execute\_sql method, is executed from using the cursor, which will make the appropriate change to the database.

\subsubsection{create\_table method}

\begin{python}
def create_table(self, table_name):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select name from sqlite_master where name=?",(table_name,))
            result = cursor.fetchall()
            keep_table = True
            if len(result) == 1:
                response = input("The table {0} already exists, do you wish to recreate it (y/n): ".format(table_name))
                if response == "y":
                    keep_table = False
                    print("The {0} table will be recreated - all existing data will be lost".format(table_name))
                    cursor.execute("drop table if exists {0}".format(table_name))
                    db.commit()
                else:
                    print("The existing table was kept")
            else:
                keep_table = False
            if not keep_table:
                sql = """create table Student
                (TaskID text,
                Qone integer,
                Qtwo integer,
                Qthree integer,
                Qfour integer,
                primary key(TaskID))"""
                cursor.execute(sql)
                db.commit()
\end{python}

This method is run as soon as the program is run; the first SQL statement searches all sqlite3 files to check if a database called student already exists, and returns all of the values, in this case either 1 or 0. If it does exist, it will ask the user whether or not they want to over-write the existing database. At the moment this is useful for testing but it will not be in the final version; the user will not be able to over-write the database unless they do it manually with the settings I might put in as a secondary objective. The variables used to check the name of the table are passed in so that they can be different, but they won't be as for now the database name is hard-coded. The SQL statement which creates the actual table uses the execute\_sql function (previous section) to connect to the database and make the changes. db.commit() makes sure the changes stay and are not forgotten.

\subsubsection{insert\_data\_first method}

\begin{python}
    def insert_data_first(self, task, correct_count):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select TaskID from Student where TaskID = '{0}'".format(task))
            info = cursor.fetchall()
            if len(info) != 0:
                sql = "UPDATE Student SET Qone = '{0}' WHERE TaskID = '{1}' AND Qone < '{2}'".format(correct_count, task, correct_count)
            else:
                sql = "insert into Student(TaskID, Qone, Qtwo, Qthree, Qfour) values ('{0}', '{1}', '{2}', '{3}', '{4}')".format(task, correct_count, str(0), str(0), str(0))
            self.execute_sql(sql)
\end{python}

This method is called in the homework page 1 subclasses. It can be called from any of the 24 subclasses, and the polymorphed variables from each one are passed through, so that, for example, there are no cross-overs of data like the Sides Easy task name being recorded as the parent default. The SQL here firstly checks to see if a task with the same task name already exists, and if it does, each value will only be over-written if it is greater than the exisitng one. Otherwise it will create a new record and save the values from the second pages as 0 so the same SQL statements can be used, update statements, whether the record existed or not before. the execute\_sql method is run in order to make the changes to the table.

\subsubsection{insert\_data\_second method}

\begin{python}
def insert_data_second(self, task, count_2, count_3, count_4):
        with sqlite3.connect(self._db_name) as db:
            sql = "UPDATE Student SET Qtwo = '{0}' WHERE TaskID = '{1}' AND Qtwo < '{2}'".format(count_2, task, count_2)
            self.execute_sql(sql)
            sql_2 = "UPDATE Student SET Qthree = '{0}' WHERE TaskID = '{1}' AND Qthree < '{2}'".format(count_3, task, count_3)
            self.execute_sql(sql_2)
            sql_3 = "UPDATE Student SET Qfour = '{0}' WHERE TaskID = '{1}' AND Qfour < '{2}'".format(count_4, task, count_4)
            self.execute_sql(sql_3)
\end{python}

The SQL statements in this method are individual so that they don't all have to be greater values than the existing value in each column to be able to over-write the previous value. These statements work regardless of whether or not a record for the task already existed because the previous method (which is always run before this one) will write 0 values to each attribute in the table. Like the insert\_data\_first method, this can be called from each homework page 2 subclass to avoid data collisions.

\subsubsection{get\_query}

\begin{python}
    def get_query(self, data, score_data):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select * from Student WHERE TaskID = '{0}' or Qone = '{1}'".format(data, score_data))
            report = cursor.fetchall()
            return report
\end{python}

This method is called in the report widget, and the SQL statement searches for data in the database which is equal to the value of the variables passed through, which come from the combo boxes where the user selects the information they want to search for. data and score\_data come from the combo boxes so that each time the button is clicked the variables can be changed and the table which displays the data is immediately updated based on the new query.

\subsubsection{GetAllNames method}

\begin{python}
def GetAllNames(self):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select * from Student")
            students = cursor.fetchall()
            return students
\end{python}

This method fetches all data currently in the database and returns it so that in the progress window, where this method is called automatically, all data is displayed in the table.

\subsection{DatabaseWidget Class}

\begin{python}
class DatabaseWidget(QWidget):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.title = QLabel("Progress")
        self.title.setFont(QFont("Courier", 40))

        self.back = QPushButton("Return")
        self.back.setMinimumWidth(60)
        self.back.setMinimumHeight(100)
        self.back.setFont(QFont("Courier", 40))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")

        self.report = QPushButton("Report")
        self.report.setMinimumWidth(60)
        self.report.setMinimumHeight(100)
        self.report.setFont(QFont("Courier", 40))
        
        self.database = QTableWidget()
        self.database.setRowCount(24)
        self.database.setColumnCount(5)
        self.database_header = ("Task Name", "Question 1", "Question 2", "Question 3", "Question 4")
        self.database.setHorizontalHeaderLabels(self.database_header)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue;}")

        self.database.setStyleSheet("QTableView {selection-background-color: #A3C1DA;}")

        students = g_database.GetAllNames()
        
        count = 0
        for student in students:
            self.database.setItem(count, 0, QTableWidgetItem(student[0]))
            self.database.setItem(count, 1, QTableWidgetItem(str(student[1])))
            self.database.setItem(count, 2, QTableWidgetItem(str(student[2])))
            self.database.setItem(count, 3, QTableWidgetItem(str(student[3])))
            self.database.setItem(count, 4, QTableWidgetItem(str(student[4])))
            count += 1

        self.layout = QGridLayout()

        self.layout.addWidget(self.title, 0, 0) 
        self.layout.addWidget(self.database, 0, 1)
        self.layout.addWidget(self.back, 4, 0)
        self.layout.addWidget(self.report, 4, 1)

        self.setLayout(self.layout)

        self.back.clicked.connect(self.selected_back)
        self.report.clicked.connect(self.selected_report)
\end{python}

This class is the class which contains the QTableWidget which displays all data from the database. This window can be accessed by clicking the progress button on the home screen. When this window is loaded, the all information is automatically fetched from the database controller and immediately displayed in the QTableWidget so the user can easily access all information. The report widget is for querying and viewing specific imformation, and can be accessed from this window. The for loop is used to display each item in the database in the right place; the list value represents the position of the piece of data in the table. For example each student[0] is a task name, and is displayed in the first column. A count increments so that the next row is accessed each time and the first record isn't constantly over-written up until the last record. This window is accessible from the home page so the user can view all progress without having to go through any other menus.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
        self.close()
\end{python}

This method simply closes the window, so the previous window is displayed. It is called when the previous button is clicked.

\subsubsection{selected\_report method}

\begin{python}
def selected_report(self):
        report_widget = ReportWidget()
        report_widget.show()
        report_widget._raise()
\end{python}

This method opens the report window when the report button is clicked.

\subsection{ReportWidget Class}

\begin{python}
class ReportWidget(QWidget):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        self.header = QLabel("Report")
        self.header.setFont(QFont("Courier", 30))

        self.task_box_label = QLabel("Please select a task\nto query: ")
        self.task_box_label.setFont(QFont("Courier", 25))

        self.task_box = QComboBox()
        self.task_box.setMinimumWidth(60)
        self.task_box.setMinimumHeight(100)
        self.task_box.setFont(QFont("Courier", 30))
        self.task_box.setStyleSheet("QComboBox {background-color: lavender; color: purple;}")
        self.task_box.addItem("")
        self.task_box.addItem("Sides Easy")
        self.task_box.addItem("Sides Medium")
        self.task_box.addItem("Sides Hard")
        self.task_box.addItem("SOHCAHTOA Easy")
        self.task_box.addItem("SOHCAHTOA Medium")
        self.task_box.addItem("SOHCAHTOA Hard")
        self.task_box.addItem("Finding Angles Easy")
        self.task_box.addItem("Finding Angles Medium")
        self.task_box.addItem("Finding Angles Hard")
        self.task_box.addItem("3D Trigonometry Easy")
        self.task_box.addItem("3D Trigonometry Medium")
        self.task_box.addItem("3D Trigonometry Hard")
        self.task_box.addItem("Pythagoras' Theorem Easy")
        self.task_box.addItem("Pythagoras' Theorem Medium")
        self.task_box.addItem("Pythagoras' Theorem Hard")
        self.task_box.addItem("3D Pythagoras Easy")
        self.task_box.addItem("3D Pythagoras Medium")
        self.task_box.addItem("3D Pythagoras Hard")
        self.task_box.addItem("Vectors Easy")
        self.task_box.addItem("Vectors Medium")
        self.task_box.addItem("Vectors Hard")
        self.task_box.addItem("Easy Summary")
        self.task_box.addItem("Medium Summary")
        self.task_box.addItem("Hard Summary")
        
        self.score_box_label = QLabel("Please input the maximum\nscore you would like\nto query: ")
        self.score_box_label.setFont(QFont("Courier", 25))

        self.score_box = QComboBox()
        self.score_box.setMinimumWidth(60)
        self.score_box.setMinimumHeight(100)
        self.score_box.setFont(QFont("Courier", 30))
        self.score_box.setStyleSheet("QComboBox {background-color: lavender; color: purple;}")
        self.score_box.addItem(None)
        self.score_box.addItem("6")
        self.score_box.addItem("5")
        self.score_box.addItem("4")
        self.score_box.addItem("3")
        self.score_box.addItem("2")
        self.score_box.addItem("1")
        self.score_box.addItem("0")

        self.back = QPushButton("Return")
        self.back.setMinimumWidth(60)
        self.back.setMinimumHeight(100)
        self.back.setFont(QFont("Courier", 30))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")
        
        self.submit = QPushButton("Query")
        self.submit.setMinimumWidth(60)
        self.submit.setMinimumHeight(100)
        self.submit.setFont(QFont("Courier", 30))
        self.submit.setStyleSheet("QPushButton {background-color: green; color: white;}")

        self.db = QTableWidget()
        self.db.setRowCount(24)
        self.db.setColumnCount(5)
        self.db_header = ("TaskName", "Question 1", "Question 2", "Question 3", "Question 4")
        self.db.setHorizontalHeaderLabels(self.db_header)
        self.db.setStyleSheet("QTableWidget {selection-background-color: #A3C1DA;}")

        self.layout = QGridLayout()

        self.setLayout(self.layout)

        self.layout.addWidget(self.db, 0, 0)
        self.layout.addWidget(self.task_box_label, 0, 1)
        self.layout.addWidget(self.task_box, 1, 1)
        self.layout.addWidget(self.score_box_label, 2, 1)
        self.layout.addWidget(self.score_box, 3, 1)
        self.layout.addWidget(self.back, 4, 0)
        self.layout.addWidget(self.submit, 4, 1)

        self.back.clicked.connect(self.selected_back)
        self.submit.clicked.connect(self.selected_submit)
\end{python}

This widget is similar to the progress window except it is used to search for specific data in the database. A QTableWidget is used to display all the relevant data which is fetched using the selected\_submit method. The window uses combo boxes to select inputs; all of the possible task names and scores are placed in the combo box for the user to choose from. This window is accessible from the progress window because it would not be convenient for it to be anywhere else; here, the user is already checking database information.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
        self.close()
\end{python}

This closes the window and the progress screen is displayed - if the user opens the report widget again the table widget will be blank, it won't save the previous query.

\subsubsection{selected\_submit method}

\begin{python}
def selected_submit(self):
        _count = 0
        data = self.task_box.currentText()
        score_data = self.score_box.currentText()
        report = g_database.get_query(data, score_data)
        for count in range(24):
            self.db.setItem(count, 0, QTableWidgetItem(None))
            self.db.setItem(count, 1, QTableWidgetItem(None))
            self.db.setItem(count, 2, QTableWidgetItem(None))
            self.db.setItem(count, 3, QTableWidgetItem(None))
            self.db.setItem(count, 4, QTableWidgetItem(None))
        for record in report:
            self.db.setItem(_count, 0, QTableWidgetItem(record[0]))
            self.db.setItem(_count, 1, QTableWidgetItem(str(record[1])))
            self.db.setItem(_count, 2, QTableWidgetItem(str(record[2])))
            self.db.setItem(_count, 3, QTableWidgetItem(str(record[3])))
            self.db.setItem(_count, 4, QTableWidgetItem(str(record[4])))
            _count += 1
\end{python}

This is the method which accesses the database using the get\_query method (DatabaseWidget Class). The information is displayed in a QTableWidget like in the progress window, only it will usually need fewer rows to display all of the fetched information. This method passes in the variables which are taken from the text in the combo boxes which are selected by the user, and fetches all information from the database which matches these variables. This method sets all of the values in the table widget to blank before it displays the new queried data so that every time a query is made the previous query's data is gone; only one query at a time is necessary.

\subsection{FirstScreen Class}

\begin{python}
class FirstScreen(QWidget):
    NameEntered = pyqtSignal()
    def __init__(self):
        super().__init__()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.message = QLabel("Welcome to the Triangle Geometry Education Program")
        self.message.setFont(QFont("Courier", 40))
        self.message.setAlignment(Qt.AlignCenter)

        self.cont = QPushButton("Continue")
        self.cont.setMinimumHeight(110)
        self.cont.setMinimumWidth(60)
        self.cont.setFont(QFont("Courier", 40))

        self.pic = QLabel()
        self.pic.setPixmap(QPixmap("powered_by_python"))
        self.pic.setAlignment(Qt.AlignCenter)

        self.layout = QGridLayout()

        self.setLayout(self.layout)

        self.layout.addWidget(self.pic, 0, 0) 
        self.layout.addWidget(self.message, 1, 0)
        self.layout.addWidget(self.cont, 2, 0)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue;}")

        self.cont.clicked.connect(self.enter)
\end{python}

This class contains the template for the first screen which is displayed when the system is run; this screen is only displayed at the start, once the user selects continue it cannot be accessed again until the next session. Its main purpose is to be user friendly and give the user a comprehensible start to the system. HTML is included in the PyQt, which sets the positioning of the widgets in the window and changes the size and colour of the button and text. This is part of a stack widget so that it does not remain open behind the home screen; the home screen replaces it. A pyqtSignal is used to send the signal for the connection when the continue button is clicked to change the current screen.

\subsubsection{enter method}

\begin{python}
def enter(self):
	self.nameEntered.emit()
\end{python}

This method contains the signal which tells python to switch to the next screen when the button is clicked - it essentially changes nameEntered to true, which is the condition to display the home screen in place of the first screen.

\subsection{UserAccountWidget Class}

\begin{python}
class UserAccountWidget(QWidget):
    def __init__(self, parent):
        super().__init__()
        
        self.parent_window = parent

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.lessons = QPushButton("Lessons")
        self.lessons.setMinimumWidth(90)
        self.lessons.setMinimumHeight(110)
        self.lessons.setFont(QFont("Courier", 40))

        self.homework = QPushButton("Homework")
        self.homework.setMinimumWidth(90)
        self.homework.setMinimumHeight(110)
        self.homework.setFont(QFont("Courier", 40))

        self.progress = QPushButton("Progress")
        self.progress.setMinimumWidth(90)
        self.progress.setMinimumHeight(110)
        self.progress.setFont(QFont("Courier", 40))
        
        self.lessons_label = QLabel("To view lessons\nand learn more,\nclick here! ")
        self.lessons_label.setFont(QFont("Courier", 25))
        
        self.homework_label = QLabel("To access the\nhomework set for\nyou to complete,\nclick here! ")
        self.homework_label.setFont(QFont("Courier", 25))
        
        self.database_label = QLabel("To view your\nprogress so far,\nclick here! ")
        self.database_label.setFont(QFont("Courier", 25))
        
        self.log_out = QPushButton("Exit Program")
        self.log_out.setMinimumWidth(90)
        self.log_out.setMinimumHeight(110)
        self.log_out.setFont(QFont("Courier", 40))
        self.log_out.setStyleSheet("QPushButton {background-color: green; color: white; font-size: 20;}")

        self.picture = QLabel()
        self.picture.setPixmap(QPixmap("student_account_home_pic"))
        self.picture.setAlignment(Qt.AlignCenter)
        
        self.homework_pic = QLabel()
        self.homework_pic.setPixmap(QPixmap("student_home_homework"))
        self.homework_pic.setAlignment(Qt.AlignCenter)  
        
        self.smiler = QLabel()
        self.smiler.setPixmap(QPixmap("smile"))
        self.smiler.setAlignment(Qt.AlignCenter)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue; font-size: 20;}")

        self.layout = QGridLayout()

        self.layout.addWidget(self.lessons, 0, 1)
        self.layout.addWidget(self.picture, 0, 2)
        self.layout.addWidget(self.homework, 1, 1)
        self.layout.addWidget(self.progress, 2, 1)
        self.layout.addWidget(self.lessons_label, 0, 0)
        self.layout.addWidget(self.homework_label, 1, 0)
        self.layout.addWidget(self.database_label, 2, 0)
        self.layout.addWidget(self.picture, 1, 3)
        self.layout.addWidget(self.log_out, 2, 3)
        self.layout.addWidget(self.smiler, 2, 2)
        self.layout.addWidget(self.homework_pic, 1, 2)

        self.setLayout(self.layout)

        self.lessons.clicked.connect(self.selected_lessons)
        self.homework.clicked.connect(self.selected_homework)
        self.progress.clicked.connect(self.selected_progress)
        self.log_out.clicked.connect(self.log_out_selected)
\end{python}

This class is the template for the second window in the stack with the first screen (FirstScreen Class) and is accessed by clicking continue from the first screen. This window has the buttons with connections to every other screen in the window; in other words, the top of the branch. The lessons button takes the user to menus where they can find lessons, the homework button takes them to homework menus, and the progress buttons opens the database viewer. This window is always open so the user can finish a task, close it, and be returned here to select their next task. It also contains the exit program button which closes the entire system immediately, with no messages asking if they're sure, and no windows are left open.

\subsubsection{log\_out\_selected method}

\begin{python}
def log_out_selected(self):
        sys.exit()
\end{python}

This method is connected to the exit program button and closes down the entire system. All data in the database is saved in a separate file so there is no need to try and keep anything open or remember any inputs which haven't been saved yet; they just have to go back and do it again.

\subsubsection{selected\_lessons method}

\begin{python}
def selected_lessons(self):
        lessonmenuwidget = LessonMenuWidget()
        lessonmenuwidget.show()
        lessonmenuwidget._raise()
        lessonmenuwidget.showMaximized()
\end{python}

This simply opens the lesson menu which is in a separate window, so when they press return or close that window, the home screen will still be open ready to access any other part of the system or close it down.

\subsubsection{selected\_homework method}

\begin{python}
def selected_homework(self):
        homeworkmenuwidget = HomeworkMenuWidget()
        homeworkmenuwidget.show()
        homeworkmenuwidget._raise()
        homeworkmenuwidget.showMaximized()
\end{python}

This simply opens the homework menu which is in a separate window, so when they press return or close that window, the home screen will still be open ready to access any other part of the system or close it down.

\subsubsection{selected\_progress method}

\begin{python}
def selected_progress(self):
        databasewidget = DatabaseWidget()
        databasewidget.show()
        databasewidget._raise()
        databasewidget.showMaximized()  
\end{python}

This simply opens the progress menu which is in a separate window, so when they press return or close that window, the home screen will still be open ready to access any other part of the system or close it down.

\subsection{LessonMenuWidget Class}

\begin{python}
class LessonMenuWidget(QMainWindow):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.t1 = QPushButton("Trigonometry 1")
        self.t1.setMinimumWidth(90)
        self.t1.setMinimumHeight(110)
        self.t1.setFont(QFont("Courier", 40))
        
        self.t1_pic = QLabel()
        self.t1_pic.setPixmap(QPixmap("t1_pic"))
        self.t1_pic.setAlignment(Qt.AlignCenter)
        
        self.t2 = QPushButton("Trigonometry 2")
        self.t2.setMinimumWidth(90)
        self.t2.setMinimumHeight(110)
        self.t2.setFont(QFont("Courier", 40))
        
        self.t2_pic = QLabel()
        self.t2_pic.setPixmap(QPixmap("t2_pic"))
        self.t2_pic.setAlignment(Qt.AlignCenter)
        
        self.pyt = QPushButton("Pythagoras")
        self.pyt.setMinimumWidth(90)
        self.pyt.setMinimumHeight(110)
        self.pyt.setFont(QFont("Courier", 40))
        
        self.pyt_pic = QLabel()
        self.pyt_pic.setPixmap(QPixmap("pyt_pic"))
        self.pyt_pic.setAlignment(Qt.AlignCenter)
        
        self.pytrig = QPushButton("Vectors")
        self.pytrig.setMinimumWidth(90)
        self.pytrig.setMinimumHeight(110)
        self.pytrig.setFont(QFont("Courier", 40))
        
        self.pytrig_pic = QLabel()
        self.pytrig_pic.setPixmap(QPixmap("pytrig_pic"))
        self.pytrig_pic.setAlignment(Qt.AlignCenter)
        
        self.sum = QPushButton("Summary")
        self.sum.setMinimumWidth(90)
        self.sum.setMinimumHeight(110)
        self.sum.setFont(QFont("Courier", 40))
        
        self.sum_pic = QLabel()
        self.sum_pic.setPixmap(QPixmap("sum_pic"))
        self.sum_pic.setAlignment(Qt.AlignCenter)

        self.back = QPushButton("Return")
        self.back.setMinimumWidth(90)
        self.back.setMinimumHeight(110)
        self.back.setFont(QFont("Courier", 40))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")
    
        self.lesson_label = QLabel("Lessons")
        self.lesson_label.setFont(QFont("Courier", 40))
        
        self.select = QLabel("Please select a topic: ")
        self.select.setFont(QFont("Courier", 25))
        
        self.title_pic = QLabel()
        self.title_pic.setPixmap(QPixmap("title_lessons"))

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue; font-size: 20;}")

        self.layout = QGridLayout()

        self.layout.addWidget(self.title_pic, 0, 0) 
        self.layout.addWidget(self.t1_pic, 1, 0)
        self.layout.addWidget(self.t1, 1, 1)
        self.layout.addWidget(self.t2, 2, 0)
        self.layout.addWidget(self.t2_pic, 2, 1)
        self.layout.addWidget(self.pyt_pic, 3, 0)
        self.layout.addWidget(self.pyt, 3, 1)
        self.layout.addWidget(self.pytrig, 4, 0)
        self.layout.addWidget(self.pytrig_pic, 4, 1)
        self.layout.addWidget(self.sum_pic, 5, 0)
        self.layout.addWidget(self.sum, 5, 1)
        self.layout.addWidget(self.back, 6, 0)

        self._centralwidget = QWidget()
        self._centralwidget.setLayout(self.layout)
        self.setCentralWidget(self._centralwidget)

        self.t1.clicked.connect(self.selected_t1) 
        self.t2.clicked.connect(self.selected_t2)
        self.pyt.clicked.connect(self.selected_pyt)
        self.pytrig.clicked.connect(self.selected_pytrig)
        self.sum.clicked.connect(self.selected_sum)
        self.back.clicked.connect(self.selected_back)
\end{python}

This class is the template for the menu screen which connects to the five individual subclassed menus which contain the buttons for the specific lessons; it is the middle screen in a branch menu of three screens. It is accessed by clicking the lessons button on the home screen (UserAccountHome Class), and it connects to five different final menus from which the user can access the lessons. This structure is used to make it easier to navigate to specific lesson topics, and to fit clear and visible buttons on the page, which are all relevant to each other. 

\subsubsection{selected\_t1 method}

\begin{python}
def selected_t1(self):
        trig_1_widget = Trigonometry1()
        trig_1_widget.show()
        trig_1_widget._raise()
        trig_1_widget.showMaximized()
\end{python}

This method is connected to the trigonometry 1 button and is run when said button is clicked; one of five of the derived lesson menus opens with buttons to connect to the lessons which are all relevant to the title and each other.

\subsubsection{selected\_t2 method}

\begin{python}
def selected_t2(self):
        trig_2_widget = Trigonometry2()
        trig_2_widget.show()
        trig_2_widget._raise()
        trig_2_widget.showMaximized()
\end{python}

This method is connected to the trigonometry 2 button and is run when said button is clicked; one of five of the derived lesson menus opens with buttons to connect to the lessons which are all relevant to the title and each other.

\subsubsection{selected\_pyt method}

\begin{python}
def selected_pyt(self):
        pythagoras_widget = Pythagoras()
        pythagoras_widget.show()
        pythagoras_widget._raise()
        pythagoras_widget.showMaximized()
\end{python}

This method is connected to the pythagoras button and is run when said button is clicked; one of five of the derived lesson menus opens with buttons to connect to the lessons which are all relevant to the title and each other.

\subsubsection{selected\_pytrig method}

\begin{python}
def selected_pytrig(self):
        pyth_trig_widget = PythagTrig()
        pyth_trig_widget.show()
        pyth_trig_widget._raise()
        pyth_trig_widget.showMaximized()
\end{python}

This method is connected to the vectors button and is run when said button is clicked; one of five of the derived lesson menus opens with buttons to connect to the lessons which are all relevant to the title and each other (the topic of this section has changed since the connections were coded, hence the unusual variable name).

\subsubsection{selected\_sum method}

\begin{python}
def selected_sum(self):
        summary_widget = Summary()
        summary_widget.show()
        summary_widget._raise()
        summary_widget.showMaximized()
\end{python}

This method is connected to the summary button and is run when said button is clicked; one of five of the derived lesson menus opens with buttons to connect to the lessons which are all relevant to the title and each other.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
        self.close()
\end{python}

This method closes the window and returns the user to the home screen, which is left open for quick accessibility.

\subsection{HomeworkMenuWidget Class}

\begin{python}
class HomeworkMenuWidget(QMainWindow):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.title = QLabel()
        self.title.setFont(QFont("Courier", 40))

        self.ht1 = QPushButton("Trigonometry 1")
        self.ht1.setMinimumWidth(90)
        self.ht1.setMinimumHeight(110)
        self.ht1.setFont(QFont("Courier", 40))
        
        self.ht2 = QPushButton("Trigonometry 2")
        self.ht2.setMinimumWidth(90)
        self.ht2.setMinimumHeight(110)
        self.ht2.setFont(QFont("Courier", 40))
        
        self.hpyt = QPushButton("Pythagoras")
        self.hpyt.setMinimumWidth(90)
        self.hpyt.setMinimumHeight(110)
        self.hpyt.setFont(QFont("Courier", 40))
        
        self.hpytrig = QPushButton("Vectors")
        self.hpytrig.setMinimumWidth(90)
        self.hpytrig.setMinimumHeight(110)
        self.hpytrig.setFont(QFont("Courier", 40))
        
        self.hsum = QPushButton("Summary")
        self.hsum.setMinimumWidth(90)
        self.hsum.setMinimumHeight(110)
        self.hsum.setFont(QFont("Courier", 40))
        
        self.back = QPushButton("Return")
        self.back.setMinimumWidth(90)
        self.back.setMinimumHeight(110)
        self.back.setFont(QFont("Courier", 40))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")

        self.ht1_pic = QLabel()
        self.ht1_pic.setPixmap(QPixmap("homework_trig_1_pic"))
        self.ht1_pic.setAlignment(Qt.AlignCenter)
        
        self.ht2_pic = QLabel()
        self.ht2_pic.setPixmap(QPixmap("homework_trig_2_pic"))
        self.ht2_pic.setAlignment(Qt.AlignCenter)
        
        self.hpyt_pic = QLabel()
        self.hpyt_pic.setPixmap(QPixmap("homework_pythag_pic"))
        self.hpyt_pic.setAlignment(Qt.AlignCenter)
        
        self.hpytrig_pic = QLabel()
        self.hpytrig_pic.setPixmap(QPixmap("homework_vectors_pic"))
        self.hpytrig_pic.setAlignment(Qt.AlignCenter)
        
        self.hsum_pic = QLabel()
        self.hsum_pic.setPixmap(QPixmap("homework_summary_pic"))
        self.hsum_pic.setAlignment(Qt.AlignCenter)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue; font-size: 20;}")

        self.layout = QGridLayout()

        self.layout.addWidget(self.title, 0, 0) 
        self.layout.addWidget(self.ht1_pic, 2, 0)
        self.layout.addWidget(self.ht1, 2, 1)
        self.layout.addWidget(self.ht2, 3, 0)
        self.layout.addWidget(self.ht2_pic, 3, 1)
        self.layout.addWidget(self.hpyt_pic, 4, 0)
        self.layout.addWidget(self.hpyt, 4, 1)
        self.layout.addWidget(self.hpytrig, 5, 0)
        self.layout.addWidget(self.hpytrig_pic, 5, 1)
        self.layout.addWidget(self.hsum_pic, 6, 0)
        self.layout.addWidget(self.hsum, 6, 1)
        self.layout.addWidget(self.back, 7, 0)

        self._centralwidget = QWidget()
        self._centralwidget.setLayout(self.layout)
        self.setCentralWidget(self._centralwidget)

        self.ht1.clicked.connect(self.selected_ht1)
        self.ht2.clicked.connect(self.selected_ht2)
        self.hpyt.clicked.connect(self.selected_hpyt)
        self.hpytrig.clicked.connect(self.selected_hpytrig)
        self.hsum.clicked.connect(self.selected_hsum)
        self.back.clicked.connect(self.selected_back)
\end{python}

Pretty much the same as the LessonMenuWidget Class (LessonMenuWidget Class)This class is the template for the menu screen which connects to the five individual subclassed menus which contain the buttons for the specific homeworks; it is the middle screen in a branch menu of three screens. It is accessed by clicking the homework button on the home screen (UserAccountHome Class), and it connects to five different final menus from which the user can access the homework. This structure is used to make it easier to navigate to specific homework topics, and to fit clear and visible buttons on the page, which are all relevant to each other. 

\subsubsection{selected\_ht1 method}

\begin{python}
def selected_ht1(self):
        trigonometry_1_homework = Trigonometry1HW()
        trigonometry_1_homework.show()
        trigonometry_1_homework._raise()
        trigonometry_1_homework.showMaximized()
\end{python}

This method is connected to the trigonometry 1 button and is run when said button is clicked; one of five of the derived homework menus opens with buttons to connect to the homework which are all relevant to the title and each other.

\subsubsection{selected\_ht2 method}

\begin{python}
def selected_ht2(self):
        trigonometry_2_homework = Trigonometry2HW()
        trigonometry_2_homework.show()
        trigonometry_2_homework._raise()
        trigonometry_2_homework.showMaximized()
\end{python}

This method is connected to the trigonometry 2 button and is run when said button is clicked; one of five of the derived homework menus opens with buttons to connect to the homework which are all relevant to the title and each other.

\subsubsection{selected\_hpyt method}

\begin{python}
def selected_hpyt(self):
        pythagoras_homework = PythagorasHW()
        pythagoras_homework.show()
        pythagoras_homework._raise()
        pythagoras_homework.showMaximized()
\end{python}

This method is connected to the pythagoras button and is run when said button is clicked; one of five of the derived homework menus opens with buttons to connect to the homework which are all relevant to the title and each other.

\subsubsection{selected\_hpytrig method}

\begin{python}
def selected_hpytrig(self):
        pythag_trig_homework = PythagTrigonometryHW()
        pythag_trig_homework.show()
        pythag_trig_homework._raise()
        pythag_trig_homework.showMaximized()
\end{python}

This method is connected to the vectors button and is run when said button is clicked; one of five of the derived homework menus opens with buttons to connect to the homework which are all relevant to the title and each other.

\subsubsection{selected\_hsum method}

\begin{python}
def selected_hsum(self):
        summary_homework = SummaryHW()
        summary_homework.show()
        summary_homework._raise()
        summary_homework.showMaximized()
\end{python}

This method is connected to the summary button and is run when said button is clicked; one of five of the derived homework menus opens with buttons to connect to the homework which are all relevant to the title and each other.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
        self.close()
\end{python}

This method closes the window and returns the user to the home screen, which is left open for quick accessibility.

\subsection{ParentLessonMenu Class}

\begin{python}
class ParentLessonMenu(QWidget):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.title = QLabel()

        self.button_1 = QPushButton()
        self.button_1.setMinimumHeight(110)
        self.button_1.setMinimumWidth(60)
        self.button_1.setFont(QFont("Courier", 40))
        
        self.button_2 = QPushButton()
        self.button_2.setMinimumHeight(110)
        self.button_2.setMinimumWidth(60)
        self.button_2.setFont(QFont("Courier", 40))
        
        self.button_3 = QPushButton()
        self.button_3.setMinimumHeight(110)
        self.button_3.setMinimumWidth(60)
        self.button_3.setFont(QFont("Courier", 40))
   
        self.back = QPushButton("Return")
        self.back.setMinimumHeight(100)
        self.back.setMinimumWidth(60)
        self.back.setFont(QFont("Courier", 40))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue}")

        self.layout = QGridLayout()

        self.setLayout(self.layout)

        self.layout.addWidget(self.back, 3, 0)

        self.back.clicked.connect(self.selected_back)
\end{python}

This is the parent class which provides all of the default attributes for the derived lesson menus (e.g. Trigonometry1(ParentLessonMenu), Trigonometry1 Class). The derived lesson menu file imports from this file, and the five subclasses inherit these attributes, along with some polymorphism to make them different from one another. These subclasses are connected by buttons in the previous menu (LessonMenuWidget Class) and contain buttons to the individual lessons; there are three buttons made in the parent class here, then  one, two or three of them can be added to the layout in each subclass depending on how many lessons there are. All of the connections, along with methods to open the corresponding window, are in the subclasses so that the three buttons can be over-ridden to connect to various lessons.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
	self.close()
\end{python}

This will close the window and the user will be returned to the previous menu (LessonMenuWidget Class) if they want to change topic.

\subsection{ParentHomeworkMenuClass Class}

\begin{python}
class ParentHomeworkMenuClass(QWidget):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.title = QLabel()

        self.button_1 = QPushButton()
        self.button_1.setMinimumHeight(110)
        self.button_1.setMinimumWidth(60)
        self.button_1.setFont(QFont("Courier", 40))
        
        self.button_2 = QPushButton()
        self.button_2.setMinimumHeight(110)
        self.button_2.setMinimumWidth(60)
        self.button_2.setFont(QFont("Courier", 40))
        
        self.button_3 = QPushButton()
        self.button_3.setMinimumHeight(110)
        self.button_3.setMinimumWidth(60)
        self.button_3.setFont(QFont("Courier", 40))
        
        self.button_4 = QPushButton()
        self.button_4.setMinimumHeight(110)
        self.button_4.setMinimumWidth(60)
        self.button_4.setFont(QFont("Courier", 40))
        
        self.button_5 = QPushButton()
        self.button_5.setMinimumHeight(110)
        self.button_5.setMinimumWidth(60)
        self.button_5.setFont(QFont("Courier", 40))
        
        self.button_6 = QPushButton()
        self.button_6.setMinimumHeight(110)
        self.button_6.setMinimumWidth(60)
        self.button_6.setFont(QFont("Courier", 40))

        self.back = QPushButton("Return")
        self.back.setMinimumHeight(100)
        self.back.setMinimumWidth(60)
        self.back.setFont(QFont("Courier", 40))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white;}")

        self.pic_1 = QLabel()
        self.pic_1.setAlignment(Qt.AlignCenter)

        self.pic_2 = QLabel()
        self.pic_2.setAlignment(Qt.AlignCenter)
        
        self.pic_3 = QLabel()
        self.pic_3.setAlignment(Qt.AlignCenter)
        
        self.pic_4 = QLabel()
        self.pic_4.setAlignment(Qt.AlignCenter)

        self.pic_5 = QLabel()
        self.pic_5.setAlignment(Qt.AlignCenter)
        
        self.pic_6 = QLabel()
        self.pic_6.setAlignment(Qt.AlignCenter)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue}")   

        self.layout = QGridLayout()

        self.setLayout(self.layout)

        self.layout.addWidget(self.title, 0, 0)
        self.layout.addWidget(self.back, 10, 0)

        self.back.clicked.connect(self.selected_back)
\end{python}

This is the parent class which provides all of the default attributes for the derived homework menus (e.g. Trigonometry1HW(ParentHomeworkMenuClass), Trigonometry1HW Class). The derived homework menu file imports from this file, and the five subclasses inherit these attributes, along with some polymorphism to make them different from one another. These subclasses are connected by buttons in the previous menu (HomeworkMenuWidget Class) and contain buttons to the individual lessons; there are six buttons made in the parent class here, then three or siz of them can be added to the layout in each subclass depending on how many lessons there are. All of the connections, along with methods to open the corresponding window, are in the subclasses so that the three buttons can be over-ridden to connect to various homework.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
	self.close()
\end{python}

This will close the window and the user will be returned to the previous menu (HomeworkMenuWidget Class) if they want to change topic.

\subsection{Trigonometry1(ParentLessonMenu) Class}

\begin{python}
class Trigonometry1(ParentLessonMenu):
    def __init__(self):
        super().__init__()

        self.button_1.setText("Sides")
        self.button_2.setText("SOHCAHTOA")

        self.pic = QLabel()
        self.pic.setPixmap(QPixmap("trig_1_pic"))
        self.pic.setAlignment(Qt.AlignCenter)

        self.pic_2 = QLabel()
        self.pic_2.setPixmap(QPixmap("trig_1_pic_2"))
        self.pic_2.setAlignment(Qt.AlignCenter)

        self.layout.addWidget(self.title, 0, 0)
        self.layout.addWidget(self.pic, 1, 0)
        self.layout.addWidget(self.button_2, 1, 1)
        self.layout.addWidget(self.button_1, 2, 0)
        self.layout.addWidget(self.pic_2, 2, 1)

        self.button_1.clicked.connect(self.SidesAHO)
        self.button_2.clicked.connect(self.SOHCAHTOA)
\end{python}

This class is one of the five subclasses which inherit from the ParentLessonMenu Class (ParentLessonMenu Class) and are the third in a branch consisting of three stages of screens; home screen, topic menu and derived menu. Most of the classes attributes are in the parent class, but the button names, connections and methods are coded here to over-ride and allow for difference between the five subclasses. Each button (except for the return button) connects to a stack widget which contains the first and second screen of each lesson in a stack together. Each of the five subclasses are essentially the same, and serve the same purpose; their only differences are the lessons they connect to, hence the branch system.

\subsubsection{SidesAHO method}

\begin{python}
def SidesAHO(self):
        sides_aho = Trig1StackSides()
        sides_aho.show()
        sides_aho._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the sides lesson.

\subsubsection{SOHCAHTOA method}

\begin{python}
def SOHCAHTOA(self):
        sohcahtoa = Trig1StackSOHCAHTOA()
        sohcahtoa.show()
        sohcahtoa._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the SOHCAHTOA lesson.

\subsection{Trigonometry1HW(ParentHomeworkMenuClass) Class}

\begin{python}
class Trigonometry1HW(ParentHomeworkMenuClass):
    def __init__(self):
        super().__init__()

        self.title.setPixmap(QPixmap("trig_1_title"))

        self.button_1.setText("Sides Easy")
        self.button_2.setText("Sides Medium")
        self.button_3.setText("Sides Hard")
        self.button_4.setText("SOHCAHTOA Easy")
        self.button_5.setText("SOHCAHTOA Medium")
        self.button_6.setText("SOHCAHTOA Hard")

        self.pic_1.setPixmap(QPixmap("trig_1_pic_1_h"))
        self.pic_2.setPixmap(QPixmap("trig_1_pic_2_h"))
        self.pic_3.setPixmap(QPixmap("trig_1_pic_3_h"))
        self.pic_4.setPixmap(QPixmap("trig_1_pic_4_h"))
        self.pic_5.setPixmap(QPixmap("trig_1_pic_5_h"))
        self.pic_6.setPixmap(QPixmap("trig_1_pic_6_h"))

        self.layout.addWidget(self.button_1, 1, 0)
        self.layout.addWidget(self.pic_1, 1, 1)
        self.layout.addWidget(self.pic_2, 2, 0)
        self.layout.addWidget(self.button_2, 2, 1)
        self.layout.addWidget(self.button_3, 3, 0)
        self.layout.addWidget(self.pic_3, 3, 1)
        self.layout.addWidget(self.pic_4, 4, 0)
        self.layout.addWidget(self.button_4, 4, 1)
        self.layout.addWidget(self.button_5, 5, 0)
        self.layout.addWidget(self.pic_5, 5, 1)
        self.layout.addWidget(self.pic_6, 6, 0)
        self.layout.addWidget(self.button_6, 6, 1)

        self.button_1.clicked.connect(self.sides_aho_easy)
        self.button_2.clicked.connect(self.sides_aho_medium)
        self.button_3.clicked.connect(self.sides_aho_hard)
        self.button_4.clicked.connect(self.sohcahtoa_easy)
        self.button_5.clicked.connect(self.sohcahtoa_medium)
        self.button_6.clicked.connect(self.sohcahtoa_hard)
\end{python}

Essentially serving the same purpise as the Trigonometry1(ParentLessonMenuClass), only it connects to the homeworks from the homework button on the home screen, this class is one of the five subclasses which inherit from the ParentHomeworkMenuClass Class (ParentHomeworkMenuClass Class) and are the third in a branch consisting of three stages of screens; home screen, topic menu and derived menu. Most of the classes attributes are in the parent class, but the button names, connections and methods are coded here to over-ride and allow for difference between the five subclasses. Each button (except for the return button) connects to a stack widget which contains the first and second screen of each homework in a stack together. Each of the five subclasses are essentially the same, and serve the same purpose; their only differences are the homework they connect to, hence the branch system.

\subsubsection{sides\_aho\_easy method}

\begin{python}
def sides_aho_easy(self):
        sides_aho_1 = Trig1StackSidesEasy()
        sides_aho_1.show()
        sides_aho_1._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the sides easy homework.

\subsubsection{sides\_aho\_medium method}

\begin{python}
def sides_aho_medium(self):
        sides_aho_2 = Trig1StackSidesMedium()
        sides_aho_2.show()
        sides_aho_2._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the sides medium homework.

\subsubsection{sides\_aho\_hard method}

\begin{python}
def sides_aho_hard(self):
        sides_aho_3 = Trig1StackSidesHard()
        sides_aho_3.show()
        sides_aho_3._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the sides hard homework.

\subsubsection{sohcahtoa\_easy method}

\begin{python}
def sohcahtoa_easy(self):
        sohcahtoa_1 = Trig1StackSOHCAHTOAEasy()
        sohcahtoa_1.show()
        sohcahtoa_1._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the SOHCAHTOA easy homework.

\subsubsection{sohcahtoa\_medium method}

\begin{python}
def sohcahtoa_medium(self):
        sohcahtoa_2 = Trig1StackSOHCAHTOAMedium()
        sohcahtoa_2.show()
        sohcahtoa_2._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the SOHCAHTOA medium homework.

\subsubsection{sohcahtoa\_hard method}

\begin{python}
def sohcahtoa_hard(self):
        sohcahtoa_3 = Trig1StackSOHCAHTOAHard()
        sohcahtoa_3.show()
        sohcahtoa_3._raise()
\end{python}

This connects to the stack widget which contains both the first and second screen of the SOHCAHTOA hard homework.

\subsection{Trig1StackSides Class}

\begin{python}
class Trig1StackSides(QMainWindow):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        self.first_widget = SidesAHOWidget(self)
        self.second_widget = SidesAHOWidgetPage2(self)

        self.stack = QStackedLayout()

        self.stack.addWidget(self.first_widget)
        self.stack.addWidget(self.second_widget)

        self.widget = QWidget()
        self.widget.setLayout(self.stack)

        self.setCentralWidget(self.widget)
\end{python}

This is one of twelve stack classes which each contain the two screens for one lesson. This stack widget has the two screens added to the layout (imported from the files where each widget's class is coded), then when the stack is opened the first screen is displayed, and can switch to the second in the same window. This is accessed by clicking the corrersponding button in the first derived lesson menu (Trigonometry1(ParentLessonMenu) Class). The contents of both screens will be left how the user leaves them until the entire stack is closed, even if they are switching between screens.

\subsection{ParentLessonLayout Class}

\begin{python}
class ParentLessonLayout(QWidget):
    def __init__(self, parent = None):
        super().__init__()
   
        self.parent = parent

        self.title = QLabel()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.back = QPushButton("Return")
        self.back.setMinimumHeight(50)
        self.back.setMinimumWidth(60)
        self.back.setFont(QFont("Courier", 40))
        self.back.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")
        
        self.next = QPushButton("Next")
        self.next.setMinimumHeight(50)
        self.next.setMinimumWidth(60)
        self.next.setFont(QFont("Courier", 40))

        self.lesson_1 = QTextEdit()
        self.lesson_1.setMinimumHeight(400)
        self.lesson_1.setMinimumWidth(80)
        self.lesson_1.setFont(QFont("Courier", 20))
        self.lesson_1.setReadOnly(True)
        
        self.lesson_2 = QTextEdit()
        self.lesson_2.setMinimumHeight(400)
        self.lesson_2.setMinimumWidth(80)
        self.lesson_2.setFont(QFont("Courier", 20))
        self.lesson_2.setReadOnly(True)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue;}")

        self.layout = QGridLayout()

        self.layout.addWidget(self.title, 0, 0) 
        self.layout.addWidget(self.lesson_1, 1, 0)
        self.layout.addWidget(self.lesson_2, 1, 1)
        self.layout.addWidget(self.back, 3, 0)
        self.layout.addWidget(self.next, 3, 1)

        self.setLayout(self.layout)

        self.back.clicked.connect(self.selected_back)
        self.next.clicked.connect(self.selected_next_page)
\end{python}

This is the parent class which provides the default attributes to each of the twelve first lesson screens. The file with the subclasses imports from here, and this parent class is never seen by the user; only the subclasses are accessible. This contains the attributes which are shared by all subclasses, while the next page connection method is in each subclass, in order to switch to the relevant second page. The background colour and screen maximising is coded here so all subclasses will have the same background colour and will be maximised. Each subclass is placed in a stack with its corresponding second screen so that the two pages are always the right ones and relevant to each other.

\subsubsection{selected\_back method}

\begin{python}
def selected_back(self):
        self.parent.close()
\end{python}

This method closes the stack window and returns the user to the home screen.

\subsection{ParentLessonPage2 Class}

\begin{python}
class ParentLessonPage2(QWidget):
    def __init__(self, parent = None):
        super().__init__()

        self.parent = parent

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self.answer = QLineEdit()
        self.answer.setMinimumWidth(80)
        self.answer.setMinimumHeight(110)
        self.answer.setFont(QFont("Courier", 40))
        
        self.previous = QPushButton("Previous")
        self.previous.setMinimumHeight(110)
        self.previous.setMinimumWidth(60)
        self.previous.setFont(QFont("Courier", 40))
        self.previous.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")
        
        self.check = QPushButton("Check Answer")
        self.check.setMinimumHeight(110)
        self.check.setMinimumWidth(60)
        self.check.setFont(QFont("Courier", 40))
        self.check.setStyleSheet("QPushButton {background-color: yellow; color: black; font-size: 20;}")
        
        self.finish = QPushButton("Finish")
        self.finish.setMinimumHeight(110)
        self.finish.setMinimumWidth(60)
        self.finish.setFont(QFont("Courier", 40))
        self.finish.setStyleSheet("QPushButton {background-color: green; color: white; font-size: 20;}")

        self.text_1 = QTextEdit()
        self.text_1.setMinimumWidth(80)
        self.text_1.setMinimumHeight(110)
        self.text_1.setFont(QFont("Courier", 20))
        self.text_1.setReadOnly(True)
        
        self.text_2 = QTextEdit()
        self.text_2.setMinimumWidth(80)
        self.text_2.setMinimumHeight(110)
        self.text_2.setFont(QFont("Courier", 20))
        self.text_2.setReadOnly(True)

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue;}")

        self.layout = QGridLayout()

        self.setLayout(self.layout)

        self.layout.addWidget(self.text_1, 0, 0) 
        self.layout.addWidget(self.text_2, 0, 1)
        self.layout.addWidget(self.previous, 3, 0)
        self.layout.addWidget(self.answer, 3, 1)
        self.layout.addWidget(self.finish, 4, 0)
        self.layout.addWidget(self.check, 4, 1)

        self.previous.clicked.connect(self.previous_selected)
        self.check.clicked.connect(self.check_selected)
        self.finish.clicked.connect(self.finish_selected)
\end{python}

This is the parent class which provides the default attributes to each of the twelve second lesson screens. The file with the subclasses imports from here, and this parent class is never seen by the user; only the subclasses are accessible. This contains the attributes which are shared by all subclasses, while the previous page connection method is in each subclass, in order to switch to the relevant first page. The background colour and screen maximising is coded here so all subclasses will have the same background colour and will be maximised. Each subclass is placed in a stack with its corresponding first screen so that the two pages are always the right ones and relevant to each other.

\subsubsection{previous\_selected method}

\begin{python}
def previous_selected(self):
        self.parent.stack.setCurrentIndex(0)
\end{python}

This method connects to the first screen in the stack widget which this screen is also in (Trig1StackSides class) - this method does not need to be over-ridden because the variable which is the first screen in the stack index is declared in the stack itself, which was connected to from the derived lesson menu (Trigonometry1(ParentLessonMenu) Class).
 
\subsubsection{check\_selected method}

\begin{python}
def check_selected(self):
        if self.answer.text() == self.answer_lesson:
            self.answer.setText("{0} Correct".format(self.answer_lesson))
        else:
            self.answer.setText("Incorrect")
        self.answer.setReadOnly(True)
        self.check.setEnabled(False)
\end{python}

This method checks the input from the user up against the hard-coded variable which is set in each subclass - the variable is passed in from the subclass so the method can use entirely the same code for each subclass, hence why it is in the parent class.

\subsubsection{finish\_selected method}

\begin{python}
def finish_selected(self):
        self.parent.close()
\end{python}

This just closes the stack and returns the user to the home screen, so it can be in the parent class too.

\subsection{SidesAHOWidget(ParentLessonLayout) Class}

\begin{python}
class SidesAHOWidget(ParentLessonLayout):
    def __init__(self, parent):
        super().__init__()

        self.parent = parent

        self.title.setPixmap(QPixmap("sides_lesson_title"))

        self.lesson_1.setText("Every triangle has 3 sides, and each side has a name.\nThe HYPOTENUSE is the longest side, and is always oppposite the right-angle of a triangle.\nThe length can be found using Pythagoras' Theorem of a\u00b2 + b\u00b2 = c\u00b2.\nSine function: sin(x) = Opposite {0} Hypotenuse".format(chr(247)))

        self.lesson_2.setText("The OPPOSITE is the side opposite the angle being used.\nCosine function: cos(x) = Adjacent {0} Hypotenuse".format(chr(247)))
\end{python}

This is one of the twelve first lesson screens which inherits from the parent lesson page 1 class (ParentLessonLayout Class) and is placed in a stack widget (Trig1StackSides Class) with the corresponding second sides lesson screen. This way it is not possible for only one of the two lesson screens to be open at any time, as they are in the same stack which keeps changes until it is closed entirely.

\subsubsection{selected\_next\_page method}

\begin{python}
def selected_next_page(self):
        self.parent.stack.setCurrentIndex(1)
\end{python}

This method switches to the second screen which shares the stack widget with this widget (Trig1StackSides Class).

\subsection{SidesAHOWidgetPage2(ParentLessonPage2) Class}

\begin{python}
class SOHCAHTOAWidgetPage2(ParentLessonPage2):
    def __init__(self, parent):
        super().__init__()
        
        self.parent = parent

        self.answer.setText("m")

        self.text_1.setText("Example 1:\n1. Label O, A, H\n2. Write down SOHCAHTOA\n3. Two sides are involved: O,H\n4. So use O {0} S x H\n5. We want to find H so cover it up to leave H = (O {0} S(0))\n6. Translate: Press 15 {0} SIN(35) = 26.151702, so ans = 26.2m\n7. Check it's sensible: Yes, it's about twice as big as 15, as the diagram suggests.".format(chr(247)))
        self.text_1.setMinimumHeight(380)
        
        self.text_2.setText("You have to figure out yourself which formula to use to find this answer.\nHere's a hint: cut the triangle down the middle and it becomes a right-angled triangle.\n \n \n \n \n \n \nPut your answer in the box below:")      
        self.text_2.setMinimumHeight(380)

        self.pic = QLabel()
        self.pic.setPixmap(QPixmap("sohcahtoa_lesson_pic_2.png"))
        self.pic.setAlignment(Qt.AlignCenter)

        self.pic_2 = QLabel()
        self.pic_2.setPixmap(QPixmap("sohcahtoa_lesson_pic_3.png"))
        self.pic_2.setAlignment(Qt.AlignCenter)

        self.layout.addWidget(self.pic, 2, 0)
        self.layout.addWidget(self.pic_2, 2, 1)

        self.answer_lesson = "26.5m"
\end{python}

This class is one of the twelve second lesson screens which inherits from the lesson page 2 parent class (ParentLessonPage2 Class) and is placed in a stack widget (Trig1StackSOHCAHTOA Class) with the corresponding first sides lesson screen. This way it is not possible for only one of the two lesson screens to be open at any time, as they are in the same stack which keeps changes until it is closed entirely.

\subsection{Trig1StackSidesEasy Class}

\begin{python}
class Trig1StackSidesEasy(QMainWindow):
    def __init__(self):
        super().__init__()

        self.showMaximized()

        self.first_widget = SidesAHOEasyWidget(self)
        self.second_widget = SidesAHOEasyWidget2(self)

        self.stack = QStackedLayout()

        self.stack.addWidget(self.first_widget)
        self.stack.addWidget(self.second_widget)

        self.widget = QWidget()
        self.widget.setLayout(self.stack)

        self.setCentralWidget(self.widget)
\end{python}

This is one of twenty-four stack classes which each contain the two screens for one homework. This stack widget has the two screens added to the layout (imported from the files where each widget's class is coded), then when the stack is opened the first screen is displayed, and can switch to the second in the same window. This is accessed by clicking the corrersponding button in the first derived homework menu (Trigonometry1HW(ParentHomeworkMenuClass) Class). It is useful to have the two homework screens in a stack together so the user cannot close one screen and skip to the next, or vice-versa and repeat a page, potentially crashing the program. The use can return to one page, but the second will still be there, and they cannot re-submit the score of the first page until the second page has been closed and the stack is closed entirely and they re-do the whole homework. The contents of both screens will be left how the user leaves them until the entire stack is closed, even if they are switching between screens.

\subsection{ParentHomeworkPage1Class Class}

\begin{python}
class ParentHomeworkPage1Class(QWidget):
    def __init__(self, parent = None):
        super().__init__()

        self.parent = parent
        
        self.showMaximized()

        self.task = ""

        self.allow_cont = False

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)     

        self.next = QPushButton("Next")
        self.next.setMinimumHeight(110)
        self.next.setMinimumWidth(60)
        self.next.setFont(QFont("Courier", 40))

        self.cancel = QPushButton("Cancel")
        self.cancel.setMinimumHeight(110)
        self.cancel.setMinimumWidth(60)
        self.cancel.setFont(QFont("Courier", 40))
        self.cancel.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")
        
        self.check = QPushButton("Check Answers")
        self.check.setMinimumHeight(110)
        self.check.setMinimumWidth(60)
        self.check.setFont(QFont("Courier", 40))
        self.check.setStyleSheet("QPushButton {background-color: yellow; color: black; font-size: 20;}")
        
        self.reset = QPushButton("Reset Answers")
        self.reset.setMinimumHeight(110)
        self.reset.setMinimumWidth(60)
        self.reset.setFont(QFont("Courier", 40))
        self.reset.setStyleSheet("QPushButton {background-color: yellow; color: black; font-size: 20;}")

        self.title = QLabel()
        self.title.setFont(QFont("Courier", 40))

        self.question_1 = QLabel()
        self.question_1.setFont(QFont("Courier", 20))

        self.question_1_shape = QLabel()
        self.question_1_shape.setFont(QFont("Courier", 40))
        
        self.answer_a = QLineEdit()
        self.answer_a.setMinimumHeight(70)
        self.answer_a.setMinimumWidth(60)
        self.answer_a.setFont(QFont("Courier", 30))
        
        self.answer_b = QLineEdit()
        self.answer_b.setMinimumHeight(70)
        self.answer_b.setMinimumWidth(60)
        self.answer_b.setFont(QFont("Courier", 30))
        
        self.answer_c = QLineEdit()
        self.answer_c.setMinimumHeight(70)
        self.answer_c.setMinimumWidth(60)
        self.answer_c.setFont(QFont("Courier", 30))
        
        self.answer_d = QLineEdit()
        self.answer_d.setMinimumHeight(70)
        self.answer_d.setMinimumWidth(60)
        self.answer_d.setFont(QFont("Courier", 30))
        
        self.answer_e = QLineEdit()
        self.answer_e.setMinimumHeight(70)
        self.answer_e.setMinimumWidth(60)
        self.answer_e.setFont(QFont("Courier", 30))
        
        self.answer_f = QLineEdit()
        self.answer_f.setMinimumHeight(70)
        self.answer_f.setMinimumWidth(60)
        self.answer_f.setFont(QFont("Courier", 30))

        self.q1a = QLabel("")
        self.q1a.setFont(QFont("Courier", 20))
        
        self.q1b = QLabel("")
        self.q1b.setFont(QFont("Courier", 20))
        
        self.q1c = QLabel("")
        self.q1c.setFont(QFont("Courier", 20))
        
        self.q1d = QLabel("")
        self.q1d.setFont(QFont("Courier", 20))
        
        self.q1e = QLabel("")
        self.q1e.setFont(QFont("Courier", 20))
        
        self.q1f = QLabel("")
        self.q1f.setFont(QFont("Courier", 20))
        
        self.score_box = QLabel("Score: X/X")
        self.score_box.setFont(QFont("Courier", 30))

        self.setStyleSheet("QPushButton {background-color: #A3C1DA; color: blue;}")

        self.layout = QGridLayout()

        self.layout.addWidget(self.title, 0, 0) 
        self.layout.addWidget(self.question_1, 1, 0)
        self.layout.addWidget(self.q1a, 1, 1)
        self.layout.addWidget(self.reset, 1, 2)
        self.layout.addWidget(self.question_1_shape, 2, 0)
        self.layout.addWidget(self.answer_a, 2, 1)
        self.layout.addWidget(self.q1b, 3, 1)
        self.layout.addWidget(self.answer_b, 4, 1)
        self.layout.addWidget(self.q1c, 5, 1)
        self.layout.addWidget(self.answer_c, 6, 1)
        self.layout.addWidget(self.q1d, 7, 1)
        self.layout.addWidget(self.answer_d, 8, 1)
        self.layout.addWidget(self.q1e, 9, 1)
        self.layout.addWidget(self.answer_e, 10, 1)
        self.layout.addWidget(self.q1f, 11, 1)
        self.layout.addWidget(self.answer_f, 12, 1)
        self.layout.addWidget(self.cancel, 13, 0)
        self.layout.addWidget(self.check, 13, 1)
        self.layout.addWidget(self.next, 13, 2)

        self.setLayout(self.layout)

        self.check.clicked.connect(self.check_selected)
        self.reset.clicked.connect(self.reset_selected)
        self.cancel.clicked.connect(self.cancel_selected)
        self.next.clicked.connect(self.next_selected)

        self.answers = []
        self.answers.append(self.answer_a)
        self.answers.append(self.answer_b)
        self.answers.append(self.answer_c)
        self.answers.append(self.answer_d)
        self.answers.append(self.answer_e)
        self.answers.append(self.answer_f)
\end{python}

This is the parent class which provides the default attributes to each of the twenty-four first homework screens. The file with the subclasses imports from here, and this parent class is never seen by the user; only the subclasses are accessible. This contains the attributes which are shared by all subclasses, while the next page connection method is in each subclass, in order to switch to the relevant second page. The background colour and screen maximising is coded here so all subclasses will have the same background colour and will be maximised. Each subclass is placed in a stack with its corresponding second screen so that the two pages are always the right ones and relevant to each other.

\subsubsection{check\_selected method}

\begin{python}
def check_selected(self):
        self.allow_cont = False
        self.correct_count = 0
        if self.answer_a.text() == self.answer_1_a:
            self.answer_a.setText("{0} Correct".format(self.answer_a.text()))
            self.correct_count += 1
        else:
            self.answer_a.setText("Incorrect")
        if self.answer_b.text() == self.answer_1_b:
            self.answer_b.setText("{0} Correct".format(self.answer_b.text()))
            self.correct_count += 1
        else:
            self.answer_b.setText("Incorrect")
        if self.answer_c.text() == self.answer_1_c:
            self.answer_c.setText("{0} Correct".format(self.answer_c.text()))
            self.correct_count += 1
        else:
            self.answer_c.setText("Incorrect")
        if self.answer_d.text() == self.answer_1_d:
            self.answer_d.setText("{0} Correct".format(self.answer_d.text()))
            self.correct_count += 1
        else:
            self.answer_d.setText("Incorrect")
        if self.answer_e.text() == self.answer_1_e:
            self.answer_e.setText("{0} Correct".format(self.answer_e.text()))
            self.correct_count += 1
        else:
            self.answer_e.setText("Incorrect")
        if self.answer_f.text() == self.answer_1_f:
            self.answer_f.setText("{0} Correct".format(self.answer_f.text()))
            self.correct_count += 1
        else:
            self.answer_f.setText("Incorrect")
        for a in self.answers:
            a.setReadOnly(True)
        self.check.setEnabled(False)
        self.reset.setEnabled(False)
        self.allow_cont = True
\end{python}

This method uses variables which are passed in from each subclass, whichever one it is being called from, which are checked against hard-coded answers which are declared in the subclass too, so the variable name can be the same in the method allowing it to be written once in the parent class. The purpose of this method is to check the inputs of each of the six line edits in the subclass being used, then tell the user whether or not they are correct based on the hard-coded answers in the subclasses.

\subsubsection{next\_selected method}

\begin{python}
def next_selected(self):
        cont = False
        while not cont:
            for a in self.answers:
                if a.text() == "":
                    error_message = ErrorMessage8()
                    error_message.show()
                    error_message._raise()
                    cont = False
            cont = True
            if self.allow_cont:
                g_database.insert_data_first(self.task, self.correct_count)
                self.open_page_2()
                self.hide()
            else:
                error_message_2 = ErrorMessage8()
                error_message_2.show()
                error_message_2._raise()
\end{python}

This checks to see if the question has been fully answered before allowing the user to continue to the next screen and saving the first stage of the record in the database. this can be in the parent class because, again, the variables are hard-coded and passed through from the subclass, for the database method.

\subsubsection{reset\_selected method}

\begin{python}
def reset_selected(self):
        self.answer_a.setText(None)
        self.answer_b.setText(None)
        self.answer_c.setText(None)
        self.answer_d.setText(None)
        self.answer_e.setText(None)
        self.answer_f.setText(None)
\end{python}

this can be in the parent class because it doesn't matter what the values in the line edits are, it serves the same purpose of removing them.

\subsubsection{cancel\_selected method}

\begin{python}
def cancel_selected(self):
        self.parent.close()
\end{python}

This closes the entire stack regardless of which stack it is, hence why this method can be in the parent class.

\subsubsection{open\_page\_2 method}

\begin{python}
def open_page_2(self):
        self.parent.stack.setCurrentIndex(1)
\end{python}

The screen represented by the index of the stack is deternmined by what is hard-coded in the stack widget (Trig1SidesEasyStack Class) so the variable name is always the same, switching to the screen hard-coded into the stack, so this method can also be in the parent class.

\subsection{HomeworkPage2ParentClass Class}

\begin{python}
class HomeworkPage2ParentClass(QWidget):
    def __init__(self, parent = None):
        super().__init__()

        self.parent = parent

        self.task = ""

        self.showMaximized()

        pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)

        self._button_1 = QPushButton()
        self._button_1.setMaximumWidth(200)
        self._button_1.setMinimumWidth(110)
        self._button_1.setMinimumHeight(110)
        self._button_1.setStyleSheet("QPushButton {background-color: white; font-color: black;}")
        
        self._button_2 = QPushButton()
        self._button_2.setMaximumWidth(200)
        self._button_2.setMinimumWidth(110)
        self._button_2.setMinimumHeight(110)
        self._button_2.setStyleSheet("QPushButton {background-color: white; font-color: black;}")
  
        self._button_3 = QPushButton()
        self._button_3.setMaximumWidth(200)
        self._button_3.setMinimumWidth(110)
        self._button_3.setMinimumHeight(110)
        self._button_3.setStyleSheet("QPushButton {background-color: white; font-color: black;}")
        
        self._button_4 = QPushButton()
        self._button_4.setMaximumWidth(200)
        self._button_4.setMinimumWidth(110)
        self._button_4.setMinimumHeight(110)
        self._button_4.setStyleSheet("QPushButton {background-color: white; font-color: black;}")
        
        self._button_5 = QPushButton()
        self._button_5.setMaximumWidth(200)
        self._button_5.setMinimumWidth(110)
        self._button_5.setMinimumHeight(110)
        self._button_5.setStyleSheet("QPushButton {background-color: white; font-color: black;}")
        
        self._button_6 = QPushButton()
        self._button_6.setMaximumWidth(200)
        self._button_6.setMinimumWidth(110)
        self._button_6.setMinimumHeight(110)
        self._button_6.setStyleSheet("QPushButton {background-color: white; font-color: black;}")

        self.question_2 = QLabel()       
        self.question_2.setFont(QFont("Courier", 30))
        
        self.shape_2 = QLabel()        
        self.shape_2.setFont(QFont("Courier", 30))
        
        self.question_3 = QLabel()        
        self.question_3.setFont(QFont("Courier", 30))
        
        self.shape_3 = QLabel()       
        self.shape_3.setFont(QFont("Courier", 30))
        
        self.question_4 = QLabel()       
        self.question_4.setFont(QFont("Courier", 30))

        self.answer_2 = QComboBox()
        self.answer_2.setMinimumWidth(60)
        self.answer_2.setMinimumHeight(110)
        self.answer_2.setFont(QFont("Courier", 40))
        self.answer_2.setStyleSheet("QComboBox {background-color: lavender; color: purple;}")

        self.mark_2 = QPushButton("Mark it  |  2")
        self.mark_2.setMinimumWidth(60)
        self.mark_2.setMinimumHeight(110)
        self.mark_2.setFont(QFont("Courier", 40))
        self.mark_2.setStyleSheet("QPushButton {background-color: yellow; color: black; font-size: 20;}")
        
        self.answer_3 = QComboBox()
        self.answer_3.setMinimumWidth(60)
        self.answer_3.setMinimumHeight(110)
        self.answer_3.setFont(QFont("Courier", 40))
        self.answer_3.setStyleSheet("QComboBox {background-color: lavender; color: purple;}")
        
        self.mark_3 = QPushButton("Mark it  |  2")
        self.mark_3.setMinimumWidth(60)
        self.mark_3.setMinimumHeight(110)
        self.mark_3.setFont(QFont("Courier", 40))
        self.mark_3.setStyleSheet("QPushButton {background-color: yellow; color: black; font-size: 20;}")

        self.previous = QPushButton("Previous")
        self.previous.setMinimumWidth(60)
        self.previous.setMinimumHeight(110)
        self.previous.setFont(QFont("Courier", 40))
        self.previous.setStyleSheet("QPushButton {background-color: red; color: white; font-size: 20;}")

        self.finish = QPushButton("Finish")
        self.finish.setMinimumWidth(60)
        self.finish.setMinimumHeight(110)
        self.finish.setFont(QFont("Courier", 40))
        self.finish.setStyleSheet("QPushButton {background-color: green; color: white; font-size: 20;}")

        self.attempts_button = QPushButton("3 Attempts left")
        self.attempts_button.setMinimumHeight(60)
        self.attempts_button.setMinimumWidth(90)
        self.attempts_button.setMaximumWidth(200)
        self.attempts_button.setStyleSheet("QPushButton {background-color: white; font-color: black;}")
        self.attempts_button.setEnabled(False)

        self.layout = QGridLayout()

        self.layout.addWidget(self.question_2, 0, 0)
        self.layout.addWidget(self.shape_2, 0, 1)
        self.layout.addWidget(self.answer_2, 1, 0)
        self.layout.addWidget(self.mark_2, 1, 1)
        self.layout.addWidget(self._button_1, 1, 2)
        self.layout.addWidget(self._button_2, 1, 3)
        self.layout.addWidget(self._button_3, 2, 2)
        self.layout.addWidget(self.question_3, 2, 0)
        self.layout.addWidget(self._button_4, 2, 3)
        self.layout.addWidget(self._button_5, 3, 2)
        self.layout.addWidget(self._button_6, 3, 3)
        self.layout.addWidget(self.shape_3, 2, 1)
        self.layout.addWidget(self.attempts_button, 4, 2)
        self.layout.addWidget(self.answer_3, 3, 0)
        self.layout.addWidget(self.mark_3, 3, 1)
        self.layout.addWidget(self.question_4, 0, 2)
        self.layout.addWidget(self.previous, 5, 0)
        self.layout.addWidget(self.finish, 5, 3)

        self.setLayout(self.layout)

        self.mark_2.clicked.connect(self.selected_mark_2)
        self.mark_3.clicked.connect(self.selected_mark_3)
        self.previous.clicked.connect(self.selected_previous)
        self.finish.clicked.connect(self.selected_finish)
        self._button_1.clicked.connect(self.check_button_1)
        self._button_2.clicked.connect(self.check_button_2)
        self._button_3.clicked.connect(self.check_button_3)
        self._button_4.clicked.connect(self.check_button_4)
        self._button_5.clicked.connect(self.check_button_5)
        self._button_6.clicked.connect(self.check_button_6)

        self.attempts_remaining_a = 2
        self.attempts_remaining_b = 2
        self.attempts_remaining_c = 3
        self.correct_count_2 = 0
        self.correct_count_3 = 0
        self.correct_count_4 = 0
        self.answer_question_4 = None
\end{python}

This is the parent class which provides the default attributes to each of the twenty-four second homework screens. The file with the subclasses imports from here, and this parent class is never seen by the user; only the subclasses are accessible. This contains the attributes which are shared by all subclasses, while the previous page connection method is in each subclass, in order to switch to the relevant first page. The background colour and screen maximising is coded here so all subclasses will have the same background colour and will be maximised. Each subclass is placed in a stack with its corresponding first screen so that the two pages are always the right ones and relevant to each other.

\subsubsection{check\_button\_1 method}

\begin{python}
def check_button_1(self, attempts_remaining_c):
        self.correct_count_4 = 0
        if self._button_1.text() == self.answer_question_4:
            self._button_1.setText("Correct")
            self._button_1.setEnabled(False)
            self._button_2.setEnabled(False)
            self._button_3.setEnabled(False)
            self._button_4.setEnabled(False)
            self._button_5.setEnabled(False)
            self._button_6.setEnabled(False)
            self.attempts_button.setText("1 mark!")
            self.correct_count_4 += 1
        else:
            self._button_1.setText("Incorrect")
            self._button_1.setEnabled(False)
            self.attempts_remaining_c -= 1
            self.attempts_button.setText("{0} attempts remaining".format(self.attempts_remaining_c))
            if self.attempts_remaining_c == 0:
                self._button_1.setEnabled(False)
                self._button_2.setEnabled(False)
                self._button_3.setEnabled(False)
                self._button_4.setEnabled(False)
                self._button_5.setEnabled(False)
                self._button_6.setEnabled(False)
                self.attempts_button.setText("No more attempts")
            return self.attempts_remaining_c
\end{python}

This method checks the text on the button which was clicked to see if it matches the hard-coded answer in each subclass; the variable names of the buttons are the same, in the parent class, only the text is over-ridden, so these methods can be in the parent class as the variables being checked are the same, only their values which are passed through are different in each subclass.

\subsubsection{selected\_mark\_2 method}

\begin{python}
def selected_mark_2(self, attempts_remaining_a):
        self.correct_count_2 = 0
        if self.answer_2.currentText() == "20":
            self.correct_count_2 += 1
            self.mark_2.setText("Correct!")
            self.mark_2.setEnabled(False)
            self.answer_2.setEnabled(False)
        else:
            self.attempts_remaining_a -= 1
            self.mark_2.setText("Mark it|{0}".format(self.attempts_remaining_a))
            if self.attempts_remaining_a == 0:
                self.mark_2.setEnabled(False)
                self.answer_2.setEnabled(False)
            error_message = ErrorMessage5()
            error_message.show()
            error_message._raise()
        return self.attempts_remaining_a, self.correct_count_2
\end{python}

As with the check\_button\_1 method, the variable names of the combo boxes are the same, created in the parent class, and it is the values of the combo boxes whiuch are passed through, so the checking methods can be the same written only once in the parent class.

\subsubsection{selected\_previous method}

\begin{python}
def selected_previous(self):
        self.parent.stack.setCurrentIndex(0)
\end{python}

The screen being represented by the index here is hard-coded in the stack which is currently being operated, so this method can use the same code for each stack.

\subsubsection{selected\_finish method}

\begin{python}
def selected_finish(self):
        if self.attempts_button.text() != "1 mark!" and self.attempts_button.text() != "No more attempts":
            error_message_2 = ErrorMessage8()
            error_message_2.show()
            error_message_2._raise()
        elif self.mark_2.text() != "Correct!" and self.mark_2.text() != "Mark it|0":
            error_message_2 = ErrorMessage8()
            error_message_2.show()
            error_message_2._raise()
        elif self.mark_3.text() != "Correct!" and self.mark_3.text() != "Mark it|0":
            error_message_2 = ErrorMessage8()
            error_message_2.show()
            error_message_2._raise()
        else:
            g_database.insert_data_second(self.task, self.correct_count_2, self.correct_count_3, self.correct_count_4)
            self.parent.close()
\end{python}

This method's purpose is to check to see if the questions have been answered before saving the scores to the database and returning the user to the home screen; again, the variable names of the widgets being checked are the same and written in the parent class, only the contents of the inputs are being checked, making this method suitable for the parent class.

\subsection{SidesAHOEasyWidget(ParentHomeworkPage1Class) Class}

\begin{python}
class SidesAHOEasyWidget(ParentHomeworkPage1Class):
    def __init__(self, parent):
        super().__init__()

        self.parent = parent

        self.task = "Sides Easy"
        
        self.title.setText("Sides Easy")

        self.question_1.setText("Question 1: Look at the diagram below\nand answer the following questions: ")
        
        self.q1a.setText("Which side is oppopsite angle A? ")
    
        self.q1b.setText("Which side is adjacent to angle Q? ")
                
        self.q1c.setText("Which side is the hypotenuse? ")        

        self.q1d.setText("Which formula would you use to find AB? ")
        
        self.question_1_shape.setPixmap(QPixmap("sides_easy_q1"))

        self.answer_1_a = "BC"
        self.answer_1_b = "AC"
        self.answer_1_c = "AB"
        self.answer_1_d = "cosine"
        self.answer_1_e = "5"
        self.answer_1_f = "6"
\end{python}

This is one of the twenty-four first homework screens which inherits from the parent homework page 1 class (ParentHomeworkPage1 Class) and is placed in a stack widget (Trig1SidesEasyStack Class) with the corresponding second sides easy homework screen. This way it is not possible for only one of the two homework screens to be open at any time, as they are in the same stack which keeps changes until it is closed entirely.

\subsubsection{open\_page\_2 method}

\begin{python}
def open_page_2(self):
        self.parent.stack.setCurrentIndex(1)
\end{python}

The screen being represented by the index here is hard-coded in the stack which is currently being operated, so this method can use the same code for each stack.

\subsection{SidesAHOEasyWidget2(HomeworkPage2ParentClass) Class}

\begin{python}
class SidesAHOEasyWidget2(HomeworkPage2ParentClass):
    def __init__(self, parent):
        super().__init__()

        self.parent = parent

        self.task = "Sides Easy"

        self.question_2.setText("Question 2\nWhat is the length\nof b?")
        
        self.question_3.setText("Question 3\nWhat is the length\nof c?")
        
        self.question_4.setText("Question 4\nWhat is the\nlength of a?")

        self.answer_2.addItem("10")
        self.answer_2.addItem("20")
        self.answer_2.addItem("30")

        self.answer_3.addItem("10")
        self.answer_3.addItem("20")
        self.answer_3.addItem("30")

        self._button_1.setText("60")
        self._button_2.setText("50")
        self._button_3.setText("40")
        self._button_4.setText("30")
        self._button_5.setText("20")
        self._button_6.setText("10")

        self.answer_question_4 = "40"
\end{python}

This class is one of the twenty-four second homework screens which inherits from the homework page 2 parent class (HomeworkPage2ParentClass Class) and is placed in a stack widget (Trig1SidesEasyStack Class) with the corresponding first sides easy homework screen. This way it is not possible for only one of the two homework screens to be open at any time, as they are in the same stack which keeps changes until it is closed entirely.

\subsection{ErrorMessage2(QErrorMessage) Class}

\begin{python}
class ErrorMessage2(QErrorMessage):
    def __init__(self):
        super().__init__()
        
        message = "Invalid data type - please make sure you are inputting a decimal value"

        QErrorMessage.showMessage(self, message)
\end{python}

This is one of the error message classes which inherits from the built in QErrorMessage class; these are displayed at certain points throughout the program, mainly in the homework if a user gets a wrong answer. these are useful becuase they can all be called at any point in another file simply by importing the file with the error messages into it , similar to the database controller, where all of the SQL code is separated.

\section{Variable Listing}

\begin{center}
\begin{longtable}{|p{3cm}|p{3cm}|p{4cm}|p{4cm}|} \hline
\textbf{Variable Name} & \textbf{Data Type} & \textbf{Purpose of Variable} & \textbf{Class reference} \\ \hline
self.\_db\_name & String & This is the variable which is passed through to the create\_table method to check if this table already exists & Database Controller Class (4.3.1) \\ \hline
self.table\_name & String & This is the name of the table which is created in the create\_table method, and is passed through so the name will always be the same & Database Controller Class (4.3.1) \\ \hline
cursor & List & This variable is the structure controller for the database - it makes the changes when SQL code is executed & Database Controller Class (4.3.1) \\ \hline
result & List & This is assigned to the contents of the database which is fetched when the system checks to see if the table already exists & Database Controller Class (4.3.1) \\ \hline
info & List & This is assigned to the contents of the database which is fetched when a task is searched for to see if it exists already when saving a new record & Database Controller Class (4.3.1) \\ \hline
report & List & This is assigned to the contents of the database which is fetched when a user queries specific data in the database & Database Controller Class (4.3.1) \\ \hline
students & List & This is assigned to the contents of the database which is fetched when the progress screen is opened and all data is needed for display & Database Controller Class (4.3.1) \\ \hline
sql & String & This is the name of the variable which is always passed into the execute\_sql method whenever another method need to access the database; it is the sql statement requiring execution & Database Controller Class (4.3.1) \\ \hline
response & String & This is an input which asks the user whether or not they would like to over-write the existing database - accepts y or n & Database Controller Class (4.3.1) \\ \hline
keep\_table & Boolean & This is the boolean which checks whether the user wants to keep the existing table or not; input y for True, n for False & Database Controller Class (4.3.1) \\ \hline
g\_database & Database Class & This variable represents the entire database and is called whenever a method wants to access the database & Database Controller Class (4.3.1) \\ \hline
self.cont & None & This variable is called to make changes to the continue button's appearance and to assign connections to methods for the button,  which takes the user from the first screen to the home screen & All PyQt Windows \\ \hline
self.lessons & None & This variable is called to make changes to the lessons button's appearance and to assign connections to methods for the button, which takes the user from the home screen to the lesson topic menu & UserAccountClass (4.3.5) \\ \hline
self.homework & None & This variable is called to make changes to the homework button's appearance and to assign connections to methods for the button, which takes the user from the home screen to the homework topic menu & UserAccountClass (4.3.5) \\ \hline
self.progress & None &  This variable is called to make changes to the progress button's appearance and to assign connections to methods for the button, which takes the user from the home screen to the progress screen & UserAccountClass (4.3.5) \\ \hline
self.log\_out & None & This variable is called to make changes to the log out button's appearance and to assign connections to methods for the button, which closes the entire system when clicked & UserAccountClass (4.3.5) \\ \hline
self.t1 & None & This variable is called to make changes to the trigonometry 1 button's appearance and to assign connections to methods for the button, which takes the user from the lesson topic menu to the trigonometry 1 lesson sub menu & LessonMenuWidget (4.3.6)\\ \hline
self.ht1 & None & This variable is called to make changes to the homework trigonometry 1 button's appearance and to assign connections to methods for the button, which takes the user from the homework topic menu to the trigonometry 1 homework sub menu & HomeworkMenuWidget (4.3.7) \\ \hline
self.back & None & This variable is called to make changes to the return button's appearance and to assign connections to methods for the button, which returns the user from the screen they were on to the previous screen & All Menu Classes\\ \hline
self.report & None & This variable is called to make changes to the report button's appearance and to assign connections to methods for the button, which opens the report window from the progress window & DatabaseWidget (4.3.2) \\ \hline
self.submit & None & This variable is called to make changes to the submit button's appearance and to assign connections to methods for the button, which submits the contents of the combo boxes on the report widget to query the database & ReportWidget (4.3.3) \\ \hline
self.button\_1 & None & This variable is called to make changes to the first menu button's appearance and to assign connections to methods for the button, which takes the user from the sub menu to the corresponding lesson & ParentLessonMenuClass (4.3.8), ParentHomeworkMenuClass (4.3.9) \\ \hline
self.button\_2 & None & This variable is called to make changes to the second menu button's appearance and to assign connections to methods for the button, which takes the user from the sub menu to the corresponding lesson & ParentLessonMenuClass (4.3.8), ParentHomeworkMenuClass (4.3.9) \\ \hline
self.button\_3 & None & This variable is called to make changes to the third menu button's appearance and to assign connections to methods for the button, which takes the user from the sub menu to the corresponding lesson & ParentLessonMenuClass (4.3.8), ParentHomeworkMenuClass (4.3.9) \\ \hline
self.button\_4 & None & This variable is called to make changes to the fourth menu button's appearance and to assign connections to methods for the button, which takes the user from the sub menu to the corresponding lesson & ParentLessonMenuClass (4.3.8), ParentHomeworkMenuClass (4.3.9) \\ \hline
self.button\_5 & None & This variable is called to make changes to the fifth menu button's appearance and to assign connections to methods for the button, which takes the user from the sub menu to the corresponding lesson & ParentLessonMenuClass (4.3.8), ParentHomeworkMenuClass (4.3.9) \\ \hline
self.button\_6 & None & This variable is called to make changes to the sixth menu button's appearance and to assign connections to methods for the button, which takes the user from the sub menu to the corresponding lesson & ParentLessonMenuClass (4.3.8), ParentHomeworkMenuClass (4.3.9) \\ \hline
self.next & None & This variable is called to make changes to the next button's appearance and to assign connections to methods for the button, which switches from the first window in a stack to the second, and saves the score and task name from the first screen to the database & ParentLessonLayout (4.3.13), ParentHomeworkPage1Class (4.3.18) \\ \hline
self.previous & None & This variable is called to make changes to the previous button's appearance and to assign connections to methods for the button, which switches from the second window in a stack to the first & ParentLessonPage2 (4.3.14), HomeworkPage2ParentClass (4.3.19) \\ \hline
self.check & None & This variable is called to make changes to the check button's appearance and to assign connections to methods for the button, which checks if the contents of the line edit in the lesson is correct & ParentLessonPage2 (4.3.14), ParentHomeworkPage1Class (4.3.18) \\ \hline
self.finish & None & This variable is called to make changes to the finish button's appearance and to assign connections to methods for the button, which closes the stack widget in use and saves the scores of the second screen to the database & ParentLessonPage2 (4.3.14), HomeworkPage2ParentClass (4.3.19) \\ \hline
self.cancel & None & This variable is called to make changes to the cancel button's appearance and to assign connections to methods for the button, which closes the stack widget in use without making any changes to the database & ParentLessonLayout (4.3.13), ParentHomeworkPage1Class (4.3.18) \\ \hline
self.reset & None & This variable is called to make changes to the reset button's appearance and to assign connections to methods for the button, which clears the contents of all 6 line edits on the first homework screen & ParentHomeworkPage1Class (4.3.18) \\ \hline
self.mark\_2 & None & This variable is called to make changes to the first mark it button's appearance and to assign connections to methods for the button, which checks to see if the contents of the combo box is correct & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.mark\_3 & None & This variable is called to make changes to the second mark it button's appearance and to assign connections to methods for the button, which checks to see if the contents of the combo box is correct & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.attempts\_button & None & This variable is called to make changes to the atempts button's appearance and to assign connections to methods for the button, which simply displays the number of attempts the user has left on question 4 because it suits the design more than a QLabel & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.\_button\_1 & None & This variable is called to make changes to the first mulitple choice button's appearance and to assign connections to methods for the button, which is one of the 6 multiple choice buttons for question 4 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.\_button\_2 & None & This variable is called to make changes to the second mulitple choice button's appearance and to assign connections to methods for the button, which is one of the 6 multiple choice buttons for question 4 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.\_button\_3 & None & This variable is called to make changes to the third mulitple choice button's appearance and to assign connections to methods for the button, which is one of the 6 multiple choice buttons for question 4 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.\_button\_4 & None & This variable is called to make changes to the fourth mulitple choice button's appearance and to assign connections to methods for the button, which is one of the 6 multiple choice buttons for question 4 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.\_button\_5 & None & This variable is called to make changes to the fifth mulitple choice button's appearance and to assign connections to methods for the button, which is one of the 6 multiple choice buttons for question 4 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.\_button\_6 & None & This variable is called to make changes to the sixth mulitple choice button's appearance and to assign connections to methods for the button, which is one of the 6 multiple choice buttons for question 4 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.title & String & This variable is called to make changes to the title QLabel's appearance and position. This label tells the user the title of the window which is currently open & All PyQt Classes\\ \hline
self.header & String & This variable contains a group of strings which are assigned to be the headers of the columns on the QTableWidgets which display the contents of the database & DatabaseWidget (4.3.2), ReportWidget (4.3.3) \\ \hline
self.task\_box\_label & String & This variable is used to make changes to the task box label's appearance and position. This label asks the user to select an option from the combo box & ReportWidget (4.3.3) \\ \hline
self.score\_box\_label & String & This variable is used to make changes to the score box label's appearance and position. This label asks the user to select an option from the combo box & ReportWidget (4.3.3) \\ \hline
self.lessons\_label & String & This variable is used to make changes to the lessons label's appearance and position. This label identifies the purpose of the lessons button to the user & UserAccountwidget (4.3.5) \\ \hline
self.homework\_label & String & This variable is used to make changes to the homework label's appearance and position. This label identifies the purpose of the homework button to the user & UserAccountwidget (4.3.5) \\ \hline
self.progress\_label & String & This variable is used to make changes to the progress label's appearance and position. This label identifies the purpose of the progress button to the user & UserAccountwidget (4.3.5) \\ \hline
self.select & String & This variable is used to make changes to the select label's appearance and position. This label asks the user to select an option & LessonMenuWidget (4.3.6) \\ \hline
self.title\_pic & Blob & This variable is used to make changes to the size and position of the image assigned to the label. This image is user friendly and identifies the topic for the user & All PyQt Classes \\ \hline
self.question\_2 & String & This variable is used to make changes to the question 2 label's appearance and position. This parent label is a question which appears on each homework page 2 & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.task\_box & String, Integer, Real & This variable is used to make changes to the task query combo box's appearance and position. This combo box contains the options of tasks to query, which are passed through to the SQL statement when selected & ReportWidget (4.3.3) \\ \hline
self.score\_box & String, Integer, Real & This variable is used to make changes to the score query combo box's appearance and position. This combo box contains the options of scores to query, which are passed through to the SQL statement when selected & ReportWidget (4.3.3) \\ \hline
self.answer\_2 & String, Integer, Real & This variable is used to make changes to the answer 2 combo box's appearance and position. This combo box contains the options of answers to the generic question 2 on the second homework page & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.answer\_3 & String, Integer, Real & This variable is used to make changes to the answer 3 combo box's appearance and position. This combo box contains the options of answers to the generic question 3 on the second homework page & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.lesson\_1 & String & This variable is used to make changes to the size and position of the lesson 1 QTextEdit. This contains the first part of each generic lesson on the first lesson pages & ParentLessonLayout (4.3.13) \\ \hline
self.lesson\_2 & String & This variable is used to make changes to the size and position of the lesson 2 QTextEdit. This contains the second part of each generic lesson on the first lesson pages & ParentLessonLayout (4.3.13) \\ \hline
self.text\_1 & String & This variable is used to make changes to the size and position of the text 1 QTextEdit. This contains the third part of each generic lesson on the second lesson pages & ParentLessonPage2 (4.3.14) \\ \hline
self.text\_2 & String & This variable is used to make changes to the size and position of the text 2 QTextEdit. This contains the fourth part of each generic lesson on the second lesson pages & ParentLessonPage2 (4.3.14) \\ \hline
self.database & String, Integer & This variable is used to make changes to the size and formatting of the database QTableWidget, which contains all data fetched from the database when the progress screen is opened & DatabaseWidget (4.3.2) \\ \hline
self.db & String, Integer & This variable is used to make changes to the size and formatting of the db QTableWidget, which contains all data fetched from the database when a user queries for specific information & Reportwidget (4.3.3) \\ \hline
pal & Blob & This variable is used to set the background colour of the entire window which it is used in & All PyQt Classes \\ \hline
self.layout & None & This variable is used to assign the layout to be used as a QGridLayout, which is a useful layout for easily positioning widgets & All Classes \\ \hline
self.stack & None & This variable is used in the lesson and homework stacks to make the layout to be used a stack layout, so that one window can contain both parts of each lesson or homework & Trig1StackSides (4.3.12), Trig1SidesEasyStack (4.3.17) \\ \hline
self.widget & None & This variable is used where the stack widgets are used to set the widget type to be used as a QWidget, which contains the stack layout & All PyQt QGridLayout Classes \\ \hline
self.\_centralwidget & None & This variable is used to set the class it is in as the priority window to be opened when an event is activated; the central window to be used first & ParentLessonMenu (4.3.6), HomeworkMenuWidget (4.3.7) \\ \hline
NameEntered & Boolean & This variable is a pyqtSignal which is used to tell the system that the continue button has been clicked and allow it to switch to the home screen, which is in the stack layout with the home screen & FirstScreen (4.3.4) \\ \hline
self.parent\_window & None & This variable is used to pass down the parent values required to enable a window to be in a stack & UserAccountWidget(4.3.5) \\ \hline
self.parent & None & This variable is used to pass down the parent values required to enable a window to be in a stack & ParentLessonLayout (4.3.13), ParentLessonPage2 (4.3.14), ParentHomeworkPage1Class (4.3.18), HomeworkPage2ParentClass (4.3.19) \\ \hline
lessonmenuwidget & Class & This variable is assigned to the lesson menu widget so that it can be added to the layout and controlled for displaying and closing & UserAccountClass (4.3.5) \\ \hline
homeworkmenuwidget & Class & This variable is assigned to the homework menu widget so that it can be added to the layout and controlled for displaying and closing & UserAccountClass (4.3.5) \\ \hline
databasewidget & Class & This variable is assigned to the progress widget so that it can be added to the layout and controlled for displaying and closing & UserAccountClass (4.3.5) \\ \hline
trig\_1\_widget & Class & This variable is assigned to the trigonometry 1 lesson menu widget so that it can be added to the layout and controlled for displaying and closing & LessonMenuWidget (4.3.6) \\ \hline
trigonometry\_1\_homework & Class & This variable is assigned to the trigonometry 1 homework menu widget so that it can be added to the layout and controlled for displaying and closing & HomeworkMenuWidget (4.3.7) \\ \hline
sides\_aho & Class & This variable is assigned to the first lesson screen widget so that it can be added to the layout and controlled for displaying and closing & Trigonometry1(ParentLessonMenu) (4.3.10) \\ \hline
sides\_aho\_1 & Class & This variable is assigned to the second lesson screen widget so that it can be added to the layout and controlled for displaying and closing & Trigonometry1HW(ParentHomeworkMenuClass) (4.3.11) \\ \hline
self.first\_widget & Class & This variable is assigned to the screen at the top of the stack so that it can be added to the stack layout and controlled for displaying and closing & Trig1StackSides (4.3.12), Trig1SidesEasyStack (4.3.17) \\ \hline
self.second\_widget & Class & This variable is assigned to the second screen in the stack so that it can be added to the stack layout and controlled for displaying and closing & Trig1StackSides (4.3.12), Trig1SidesEasyStack (4.3.17) \\ \hline
report\_widget & Class & This variable is assigned to the lesson menu widget so that it can be controlled for displaying and closing & DatabaseWidget (4.3.2) \\ \hline
count & Integer & This variable is used to increment for each row that is filled when the database QTableWidget is filled so that the first row isn't constantly over-written until the last record & DatabaseWidget (4.3.2) \\ \hline
\_count & Integer & This variable is used to increment for each row that is filled when the db QTableWidget is filled so that the first row isn't constantly over-written until the last record & ReportWidget (4.3.3) \\ \hline
self.correct\_count & Integer & This variable is used in the check\_selected method in the homework page 1 parent class to count the number of line edits which contain a correct input from the user & ParentHomeworkPage1Class (4.3.18) \\ \hline
self.correct\_count\_2 & Integer & This variable is used to count the correct answers in the generic second homework questions & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.correct\_count\_3 & Integer & This variable is used to count the correct answers in the generic third homework questions & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.correct\_count\_4 & Integer & This variable is used to count the correct answers in the generic fourth homework questions & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.task & String & This is the hard-coded variable in each subclass for the homeworks which is saved to the database - it is the task name which is intended to be saved with the scores & ParentHomeworkPage1Class (4.3.18) \\ \hline
self.answer\_lesson & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the lesson answers & ParentLessonLayout (4.3.13) \\ \hline
self.answer\_1\_a & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the first of the six homework page 1 line edits & SidesAHOEasyWidget(ParentHomeworkPage1Class) (4.3.18) \\ \hline
self.answer\_1\_b & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the second of the six homework page 1 line edits & SidesAHOEasyWidget(ParentHomeworkPage1Class) (4.3.18) \\ \hline
self.answer\_1\_c & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the third of the six homework page 1 line edits & SidesAHOEasyWidget(ParentHomeworkPage1Class) (4.3.18) \\ \hline
self.answer\_1\_d & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the fourth of the six homework page 1 line edits & SidesAHOEasyWidget(ParentHomeworkPage1Class) (4.3.18) \\ \hline
self.answer\_1\_e & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the fifth of the six homework page 1 line edits & SidesAHOEasyWidget(ParentHomeworkPage1Class) (4.3.18) \\ \hline
self.answer\_1\_f & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the sixth of the six homework page 1 line edits & SidesAHOEasyWidget(ParentHomeworkPage1Class) (4.3.18) \\ \hline
self.answer\_question\_4 & Integer, Real, String & This variable is hard-coded in each subclass for the check method to compare the user's input to a question against; it is the correct answer expected for the multiple choice question for on each homework page 2 & HomeworkPage2ParentClass (4.3.19) \\ \hline
cont & Boolean & This boolean is used to decide whether or not the user can switch from the first to the second screen in a stack; if they have not answered all questions, this variable will stay false until they do & ParentHomeworkPage1Class (4.3.18) \\ \hline
self.allow\_cont & Boolean & this boolean is used to decide whether or not the user can close a homework stack; if they have not answered all questions on a homework page 2 it will stay false until they do & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.attempts\_remaining\_a & Integer & This variable is used to count how many attempts the user has at question 2 before all input methods involved in said question are disabled; it will decrement with each wrong input checked by the checking methods & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.attempts\_remaining\_b & Integer & This variable is used to count how many attempts the user has at question 3 before all input methods involved in said question are disabled; it will decrement with each wrong input checked by the checking methods & HomeworkPage2ParentClass (4.3.19) \\ \hline
self.attempts\_remaining\_c & Integer & This variable is used to count how many attempts the user has at question 4 before all input methods involved in said question are disabled; it will decrement with each wrong input checked by the checking methods & HomeworkPage2ParentClass (4.3.19) \\ \hline
data & List & This variable is passed through to the method which queries the database; it is the task name value selected in the corresponding combo box & ReportWidget (4.3.3) \\ \hline
score\_data & List & This variable is passed through to the method which queries the database; it is the score value selected in the corresponding combo box & ReportWidget (4.3.3) \\ \hline
self.answer & List & This variable is used to add the six self.answer\_1\_x variables to a list so that the same changes can be made to all of them in a for loop rather than typing the changes out separately six times & ParentHomeworkPage1Class (4.3.18)  \\ \hline
error\_message & Class & This variable is assigned to an error message class so that it can be displayed at any point in a method when necessary & ErrorMessage2(QErrorMessage) (4.3.22) \\ \hline
message & String & this is the message which is displayed in an error message class when it is called - used to tell the user what they have done wrong & ErrorMessage2(QErrorMessage) (4.3.22) \\ \hline
\end{longtable}
\end{center}

\section{System Evidence}

\subsection{User Interface}

\begin{figure}[H]
    \label{fig: Second Screen}\caption{First Screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_1}
\end{figure}

This screen is in the first window which opens whent he system is run; it contains the title of the system, a picture, and a welcome message for user friendliness, and a continue button is present for switching to the home screen.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Home Screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_2}
\end{figure}

This screen is in the same stack window as the first screen and is displayed after the continue button is clicked. It contains four buttons: lessons, homework, progress and exit program, for accessing the lesson topic menu, the homework topic menu, the database viewer and exiting the program respectively. It also contains a picture for each of the three navigation buttons which suggest where te button will take them; they are relevant to the next screens and are user friendly.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Lesson Topic Menu}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_3}
\end{figure}

This screen is displayed when the user selects the lessons button on the home screen. It contains a title image which tells the user which screen they are on, followed by five buttons, each of which navigate to a topic specific sub-menu (which all appear the same, except for text and images, as they share a parent class). Each button is accompanied by a user friendly picture relevant to the topic menu they lead to. There is a return button which closes the window and returns the user to the home screen.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Trigonometry 1 Lesson Menu}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_4}
\end{figure}

This window opens when the user clicks the first button on the lesson topic menu. It is one of five subclasses from the ParentLessonMenu, so these five windows essentially contain the same layout, only with different words, pictures and connections. They each contain a title image which tells the user which screen they are on, and have either two or three buttons, each accompanied by a picture, depending on how many lessons are in the selected topic menu. There is a return button which closes the window and returns the user to the lesson topic menu.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{SOHCAHTOA 1st Lesson screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_5}
\end{figure}

This window is accessed by clicking the corresponding button on one of the five derived lesson menus. It is one of twelve first lessons screens which inherit from a parent class; they each contain a title image, two text boxes for lessons and explanations, and cancel button, and a next button, along with one or two images depending on the lesson.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{SOHCAHTOA 2nd Lesson screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_6}
\end{figure}

This window is in the same stack as the SOHCAHTOA 1st lesson screen, is also subclassed from a parent, and is accessed by clicking the next button. It contains a further two text boxes for lessons and examples, a check button with a line edit for a practice question which you can check the answer to, a previous button to switch back to the first lesson screen, and finish button to close the stack, and one or two images, again, depending on the lesson.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Homework Topic Menu}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_7}
\end{figure}

This screen is displayed when the user selects the homework button on the home screen. It contains a title image which tells the user which screen they are on, followed by five buttons, each of which navigate to a topic specific sub-menu (which all appear the same, except for text and images, as they share a parent class). Each button is accompanied by a user friendly picture relevant to the topic menu they lead to. There is a return button which closes the window and returns the user to the home screen.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Trigonometry 1 Homework Menu}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_8}
\end{figure}

This window opens when the user clicks the first button on the homework topic menu. It is one of five subclasses from the HomeworkMenuParentClass, so these five windows essentially contain the same layout, only with different words, pictures and connections. They each contain a title image which tells the user which screen they are on, and have either three or six buttons, each accompanied by a picture, depending on how many homework tasks are in the selected topic menu. There is a return button which closes the window and returns the user to the homework topic menu.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Sides Easy 1st Homework Screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_9}
\end{figure}

This window is accessed by clicking the corresponding button on one of the five derived homework menus. It is one of twenty-four first homework screens which inherit from a parent class; they each contain a title image, a question, a reset button, a check answers button, a cancel button, a next button, and six line edits into which the user can input their answers to the question, which can be marked using the check button or all cleared using the reset button. 

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Sides Easy 2nd Lesson screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_10}
\end{figure}

This window is in the same stack as the Sides Easy 1st homework screen, is also subclassed from a parent, and is accessed by clicking the next button. It contains three questions as QLabels, two combo boxes, two mark it buttons, six multiple choice buttons, a button showing the remaining number of attempts, a previous button, and a finish button.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Progress Screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_11}
\end{figure}

This window opens when the user selects progress from the home screen. It contains a title, a return button, a report button, which opens the report widget, and a QTableWidget which contains the data fetched from the database automatically everytime the screen is loaded.

\begin{figure}[H]
    \label{fig: Second Screen}\caption{Report Screen}
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Testing/screen_12}
\end{figure}

This window opens when the user selects report from the progress screen. It contains a QTableWidget which displays the results of the query, a return button, a task combo box, a score combo box and a query button, which are used by the user to input a query for the database.

\subsection{ER Diagram}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Analysis/er_diagram.png}
    \label{fig:print_function_result}
\end{figure}

\subsection{Database Table Views}

\textbf{Task Entity: }

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Maintenance/task_db.png}
    \label{fig:print_function_result}
\end{figure}

This is the task name entity where the names of the task hard-coded from the subclass homework has been recorded along with the scores.

\textbf{Qone Entity: }

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Maintenance/q_one_db.png}
    \label{fig:print_function_result}
\end{figure}

This records the count of the number of correct line edit answers in the subclass for the task.

\textbf{Qtwo Entity: }

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Maintenance/q_two_db.png}
    \label{fig:print_function_result}
\end{figure}

This records the score of the second homework question from each subclass.

\textbf{Qthree Entity: }

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Maintenance/q_three_db.png}
    \label{fig:print_function_result}
\end{figure}

This records the score of the third homework question from each subclass.

\textbf{Qfour Entity: }

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Maintenance/q_four_db.png}
    \label{fig:print_function_result}
\end{figure}

This records the score of the fourth homework question from each subclass.

\textbf{All Entities: }

\begin{figure}[H]
    \includegraphics[width=\textwidth]{C:/Users/Jordan/git/COMP4Coursework2/Maintenance/all_db.png}
    \label{fig:print_function_result}
\end{figure}

This shows a whole record for a task that has been saved along with the scores that were obtained on said task.

\subsection{Database SQL}

\textbf{create\_table method: }

\begin{python}
def create_table(self, table_name):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select name from sqlite_master where name=?",(table_name,))
            result = cursor.fetchall()
            keep_table = True
            if len(result) == 1:
                response = input("The table {0} already exists, do you wish to recreate it (y/n): ".format(table_name))
                if response == "y":
                    keep_table = False
                    print("The {0} table will be recreated - all existing data will be lost".format(table_name))
                    cursor.execute("drop table if exists {0}".format(table_name))
                    db.commit()
                else:
                    print("The existing table was kept")
            else:
                keep_table = False
            if not keep_table:
                sql = """create table Student
                (TaskID text,
                Qone integer,
                Qtwo integer,
                Qthree integer,
                Qfour integer,
                primary key(TaskID))"""
                cursor.execute(sql)
                db.commit()
\end{python}

This method is responsible for creating the table, and is run whenever the system is run, as it also checks to see if the database already exists before starting. It connects to the database which is identified by the \textit{g\_database} variable which is passed in to the method containing the database file name. The cursor (structure controller) searches all existing database files to see if one named 'Student' (the table\_name variable also passed into the method) already exists. If it does, it asks the user whether or not they want to over-write it; if they input yes, it will the drop the current table and create a new one using the SQL statement at the end of the class. Otherwise, if the boolean keep\_table remains true, the program will just move on; likewise if the table doesn't already exist, in which the same sql statement will be used to create it. The SQL statement in this method creates the table called Student, which is the name used to check the database files at the start of the method, and gives the following entities: TaskID, which is the task name and a string, then four question entities which each contain an integer. The SQL here is executed in the same method, rather than the execute\_sql method.

\textbf{Important Database variables: }

\begin{itemize}
	\item self.\_db\_name - This is the name of the database file which is passed into the class when a variable is assigned to it (in this case it is "student\_database.db") and used to identify which database file each SQL method needs to connect to.
	\item self.table\_name - This is the name of the table which is created and is used to check to see if this table already exists, and to identify which table to make changes to when SQL code is executed.
	\item g\_database - This variable is assigned to the database class and given a file name which is passed into the class to be used for identifying the file intended for use.
\end{itemize}

\subsection{SQL Queries}

\subsubsection{create\_table method: }

\begin{python}
"select name from sqlite_master where name=?",(table_name,))
\end{python}

This SQL query takes the name of the table which is being used (Student) and uses it to check the database files to see if a table with that name already exists, so that it can be over-written if need be.

\begin{python}
"drop table if exists {0}".format(table_name))
\end{python}

This SQL query takes the table name (Student) if an existing table with that name is found, and deletes it entirely, if the user chooses to over-write it.

\begin{python}
sql = """create table Student
	(TaskID text,
	Qone integer,
	Qtwo integer,
	Qthree integer,
	Qfour integer,
	primary key(TaskID))"""
\end{python}

This SQL query creates the Student table if it does not already exist; it adds the five entities and then makes TaskID the primary key.

\subsubsection{insert\_data\_first method: }

\begin{python}
"select TaskID from Student where TaskID = '{0}'".format(task))
\end{python}

The task variable, representing the name of the task being completed, is passed through from the first homework screen in use. The SQL statement uses this variable to search the database for any records already existing with the same task name; all records where the task name is the same are fetched and returned to the method in the form of a list variable. If one is found it knows to update rather than create a new record, otherwise it just creates a new record with that task name.

\begin{python}
"UPDATE Student SET Qone = '{0}' WHERE TaskID = '{1}' AND Qone < '{2}'".format(correct_count, task, correct_count)
\end{python}

If a record with the same task name already exists, the update statement is used to record the new correct\_count (score of the first homework question) but only if the new score is better than the old one, checked using the less than symbol. The WHERE part of the statement ensures that the changes are only made to the one record with the same task name rather than all records.

\begin{python}
"insert into Student(TaskID, Qone, Qtwo, Qthree, Qfour) values ('{0}', '{1}', '{2}', '{3}', '{4}')".format(task, correct_count, str(0), str(0), str(0))
\end{python}

This is the insert statement used if a record with the same task name is not found; it saves the task name along with the score of the first homework question, then saves values of 0 in the other three questions entities. This is so that the same update statements can be used in the next method regardless of whether or not a record previously existed, as values are there to be over-written anyway because this method will always be run first due to the access limitations of the second screen (having to submit the first question score before proceeding).

\subsubsection{insert\_data\_second method: }

\begin{python}
"UPDATE Student SET Qtwo = '{0}' WHERE TaskID = '{1}' AND Qtwo < '{2}'".format(count_2, task, count_2)
\end{python}

This SQL statement overwrites the value of the Qtwo entity in the record with the same task name, which will have just been written by the previous method from the first homework screen. If the value already there is less than the new score, then it will be over-written, whether it is a fresh 0 or an existing 4. The count variable is passed through from the second homework screen which calls the method.

\begin{python}
"UPDATE Student SET Qthree = '{0}' WHERE TaskID = '{1}' AND Qthree < '{2}'".format(count_3, task, count_3)
\end{python}

This SQL statement overwrites the value of the Qthree entity in the record with the same task name, which will have just been written by the previous method from the first homework screen. If the value already there is less than the new score, then it will be over-written, whether it is a fresh 0 or an existing 4. The count variable is passed through from the second homework screen which calls the method.

\begin{python}
"UPDATE Student SET Qfour = '{0}' WHERE TaskID = '{1}' AND Qfour < '{2}'".format(count_4, task, count_4)
\end{python}

This SQL statement overwrites the value of the Qfour entity in the record with the same task name, which will have just been written by the previous method from the first homework screen. If the value already there is less than the new score, then it will be over-written, whether it is a fresh 0 or an existing 4. The count variable is passed through from the second homework screen which calls the method.

\subsubsection{get\_query method: }

\begin{python}
"select * from Student WHERE TaskID = '{0}' or Qone = '{1}'".format(data, score_data)
\end{python}

This is used to query the database using variables passed through from the contents of the combo boxes in the report widget, where the user selects which details to query. The SQL statement searches the database for records which exist containing either one of the two variable values passed through, then returns them to a list variable which can be used to display the result.

\subsubsection{GetAllNames method: }

\begin{python}
"select * from Student"
\end{python}

This SQL statement fetches all information currently stored in the database and returns it to be displayed in the progress window using a list variable to call functions.

\section{Testing}

\subsection{Summary of Results}

Throughout the testing stage I had a few manageable issues, and one quite major issue, but all of these I was able to solve without too much trouble. The biggest problem was having to cut out all administrator capabilities from the system, and turn it into a single user program, due to a lack of time and knowledge. However, referring to the parts of the system which I actually created, the system was proven to be both reliable and robust one these problems had been fixed, as there is now no point where an endless loop can be entered or a crash occurs, and all data is stored responsibly. Save the administrator aspects, the system generally meets the user requirements as it is user friendly, easy to use and contains the subject material needed to teach trigonometry using a range of input types.

The problems I encountered includes the following:

\begin{itemize}
	\item The report widget having to be put on the same screen as the query inputs as I could not find a way to pass variables through to a separate pop-up window class
	\item Not having the knowledge to implement a drag and drop system into the homework, and replacing it with a multiple choice button system
	\item Implementing separate accounts with log-ins and access restrictions for an administrator
	\item Being able to save a total score to the database due to not being able to pass the variables through to the same window to be transformed together
	\item The database would not over-write an existing record with the same task name, it would just crash, until I implemented an update SQL statement
	\item The QTableWidgets would only display one record because they kept over-writing in the first row, until I placed a for loop in to increment the row count
\end{itemize}

\textbf{Below is the results table from the testing stage: }

\begin{landscape}

\begin{center}
\begin{longtable}{|p{2.5cm}|p{4cm}|p{4cm}|p{4.5cm}|p{3cm}|} \hline
\textbf{Test Number} & \textbf{Expected Result} & \textbf{Test Data} & \textbf{Actual Result} & \textbf{Screenshot Numbers} \\ \hline
1.003 & The lessons menu should be displayed & Click the lessons button & The lessons menu was displayed, as expected & Figures 3.1, 3.2 \\ \hline
1.004 & The homework menu should be displayed & Click the homework button & The homework menu was displayed, as expected & Figures 3.3, 3.4 \\ \hline
1.005 & The progress window should be displayed & Click the progress button & The progress window was displayed, as expected & Figures 3.5, 3.6 \\ \hline
1.006 & The program should close entirely & Click the exit program button & The entire program closed, as expected & Figures 3.7, 3.8 \\ \hline
1.007 & The Trigonometry 1 lesson menu should be displayed & Click the Trigonometry 1 button & The Trigonometry 1 lesson menu was displayed, as expected & Figures 3.9, 3.10 \\ \hline
1.012 & The lesson menu should be closed and the home screen displayed & Click the return button & The lesson menu closed and the home screen was displayed, as expected & Figures 3.11, 3.12 \\ \hline
1.013 & The SOHCAHTOA first lesson screen should be displayed & Click the SOHCAHTOA button & The SOHCAHTOA first lesson screen was displayed, as expected & Figures 3.13, 3.14 \\ \hline
1.015 & The Trigonometry 1 lesson menu should be closed and the lesson menu displayed & Click the return button & The Trigonometry 1 lesson menu closed and the lesson menu was displayed, as expected & Figures 3.15, 3.16 \\ \hline
1.031 & The SOHCAHTOA first lesson screen should be closed and the Trigonometry 1 lesson menu should be displayed & Click the return button & The SOHCAHTOA first lesson screen was closed and the Trigonometry 1 lesson menu was displayed, as expected & Figures 3.17, 3.18 \\ \hline
1.032 & The SOHCAHTOA second lesson screen should replace the first SOHCAHTOA lesson screen in display & Click the next button & The second SOHCAHTOA lesson screen replaced the first SOHCAHTOA lesson screen, as expected & Figures 3.19, 3.20 \\ \hline
1.033 & The SOHCAHTOA first lesson screen should replace the second SOHCAHTOA lesson screen in display & Click the previous button & The first SOHCAHTOA lesson screen replaced the second SOHCAHTOA lesson screen, as expected & Figures 3.21, 3.22 \\ \hline
1.034 & The input typed in the line edit should be checked and the user told whether they were correct or not & Click the button & The correct answer was registered as correct and the wrong answer was registered as incorrect, as expected & Figures 3.23, 3.24 \\ \hline
1.035 & The stack window with the SOHCAHTOA lesson should close and the Trigonometry 1 lesson menu be displayed & Click the finish button & The SOHCAHTOA lesson stack was closed and the Trigonometry 1 lesson menu was displayed, as expected & Figures 3.25, 3.26 \\ \hline
1.097 & The Trigonometry 1 homework menu should be displayed & Click the trigonometry 1 button & The Trigonometry 1 homework menu was displayed, as expected & Figures 3.27, 3.28 \\ \hline
1.102 & The homework menu should close and the home screen should be displayed & Click the return button & The homework menu closed and the home screen was displayed, as expected & Figures 3.29, 3.30 \\ \hline
1.103 & The first sides easy homework screen should be displayed & Click the sides easy button & The first sides easy homework screen was displayed, as expected & Figures 3.31, 3.32 \\ \hline
1.135 & The sides easy homework stack should close and the trigonometry 1 homework menu displayed & Click the return button & The sides easy homework stack was closed and the trigonometry 1 homework menu was displayed, as expected & Figures 3.33, 3.34 \\ \hline
1.136 & The 6 line edits should be checked and the user told how many were right, and marks given & Click the check answers button & The line edits were checked, correct answers were recognised and incorrect answers were rejected, as expected & Figures 3.35, 3.36 \\ \hline
1.137 & The 6 line edits contents should all be reset to empty & Click the reset button & All 6 line edits were cleared, as expected & Figures 3.37, 3.38 \\ \hline
1.138 & The second sides easy homework screen should replace the first sides easy homework screen in the stack, and the score from the first question should be stored in the database & Click the next button & The second sides easy homework screen replaced the first sides easy homework screen in the stack, and the correct score count was stored in the database, as expected & Figures 3.39, 3.40 \\ \hline
1.139 & The input in the combo box should be checked, the user informed if they are correct or not, and marks be added or attempts removed & Click the mark it button & The correct answer was recognised and marks added, and the incorrect answer recognised and attempts removed afterwards, as expected & Figures 3.41, 3.42 \\ \hline
1.140 & The input in the combo box should be checked, the user informed if they are correct or not, and marks be added or attempts removed & Click the mark it button & The correct answer was recognised and marks added, and the incorrect answer recognised and attempts removed afterwards, as expected & Figures 3.43, 3.44 \\ \hline
1.141 & The correct button should be checked, the user informed if they are correct or not, and marks be added or attempts removed & Click each possible button & The correct answer was recognised and marks added, and the incorrect answer recognised and attempts removed afterwards, as expected & Figures 3.45, 3.46, 3.47 \\ \hline
1.142 & The first sides easy homework screen should replace the second sides easy homework screen in the stack & Click the previous button & The first sides easy homework screen replaced the second sides easy homework screen in the stack, as expected & Figures 3.48, 3.49 \\ \hline
1.143 & the sides easy homework stack should be closed and the home screen should be displayed; The scores from the questions should be stored in the database & Click the finish button & The sides easy homework stack was closed, the home screen was displayed, and the scores were saved to the database, as expected & Figures 3.50, 3.51 \\ \hline
1.380 & The progress screen should be closed and the home screen displayed & Click the return button & The progress screen was closed and the home screen was displayed, as expected & Figures 3.52, 3.53 \\ \hline
1.431 & The report screen should be closed and the progress screen displayed & Click the return button & The report screen was closed and the home screen was displayed, as expected & Figures 3.54, 3.55\\ \hline
1.432 & The relevant information should be fetched from the database and displayed in the same window & Click the query button & Relevant information was found and displayed in the database in hte same window, as expected & Figures 3.56, 3.57 \\ \hline
1.441 & The welcome screen should close and the home screen should be displayed & Click the continue button & The welcome screen was closed and the home screen was displayed, as expected & Figures 3.58, 3.59 \\ \hline
1.442 & The report screen should open and the progress screen hidden & Click the report button & The progress screen closed and the report screen was displayed, as expected & Figures 3.60, 3.61 \\ \hline
2.003 & If the input is correct, the word correct should be displayed, otherwise incorrect shoud be displayed & 5 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.62, 3.63 \\ \hline
2.016 & If the input is correct, the word correct should be displayed, otherwise incorrect should be displayed & 1 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.64, 3.65 \\ \hline
2.017 & If the input is correct, the word correct should be displayed, otherwise incorrect should be displayed & 2 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.64, 3.65 \\ \hline
2.018 & If the input is correct, the word correct should be displayed, otherwise incorrect should be displayed & 3 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.64, 3.65 \\ \hline
2.019 & If the input is correct, the word correct should be displayed, otherwise incorrect should be displayed & 4 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.64, 3.65 \\ \hline
2.020 & If the input is correct, the word correct should be displayed, otherwise incorrect should be displayed & 5 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.64, 3.65 \\ \hline
2.021 & If the input is correct, the word correct should be displayed, otherwise incorrect should be displayed & 6 (or right answer); abc; None & Correct was displayed, incorrect was displayed and an error message for no answer was displayed respectively, as expected & Figures 3.64, 3.65 \\ \hline
2.022 & If the contents of the combo box is correct, correct should appear in the button next to it, otherwise an attempt will be removed & 20; 10 & For the correct answer, correct was printed, an incorrect for the incorrect answer, as expected & Figures 3.66, 3.67 \\ \hline
2.023 & If the contents of the combo box is correct, correct should appear in the button next to it, otherwise an attempt will be removed & 40; 15 & For the correct answer, correct was printed, an incorrect for the incorrect answer, as expected & Figures  3.68, 3.69 \\ \hline
2.024 & If the right button is clicked, display correct, otherwise display incorrect & Each button in order & When the right button was clicked, a mark was added, and when the wrong buttons were clicked attempts were removed, as expected & Figures  3.70, 3.71 \\ \hline
2.295 & The information relevant to the input should be fetched from the database and displayed & Sides Easy; Pythagoras Theorem Hard & The relevant task name was fetched and displayed, as expected & Figure 3.72 \\ \hline 
2.296 & The information relevant to the input should be fetched from the database and displayed & 70\%; 80\% & The relevant scores were fetched and displayed, as expected & Figure 3.73 \\ \hline
3.009 & The task names should be stored under the 'Task Names' header in the database & Complete a task & The task name was stored under 'Task Names', as expected & Figure 3.74 \\ \hline
3.011 & The IndividualPercentScores should be stored under the 'QOne', 'QTwo', 'QThree', and 'QFour' headers respective to the question number in the database & Complete a task & The scores were under their respective headings, as expected & Figure 3.75 \\ \hline
4.015 & The correct output should be displayed for a correct or incorrect or absent input & [Correct answer]; [Incorrect answer]; None & The correct outputs were given, as expected & Figures 3.76, 3.77, 3.78 \\ \hline
4.016 & The correct output should be displayed for a correct or incorrect or absent input & [Correct answer]; [Incorrect answer]; None & The correct outputs were given, as expected & Figures 3.79, 3.80, 3.81 \\ \hline
4.017 & The correct output should be displayed for a correct or incorrect or absent input & [Correct answer]; [Incorrect answer]; None & The correct outputs were given, as expected & Figures 3.82, 3.83, 3.84 \\ \hline
4.018 & The correct output should be displayed for a correct or incorrect or absent input & [Correct answer]; [Incorrect answer]; None & The appropriate outputs were given for every possile input tested & 3.85, 3.86 \\ \hline
5.001 & The client should be satisfied with the overall system & Show the client each aspect of the system & N/A & \\ \hline
5.003 & The task names and scores should be being saved to an sqlite database, 5 columns, as many rows as there are tasks & Complete a task & There are the right number of headings in the table all with the correct information being displayed in them, as expected & Figure 3.87 \\ \hline
5.004 & Only the task names and scores should be stored in the database & Complete a task & They are the only pieces of information being stored, as expected & Figure 3.88 \\ \hline
5.006 & No illegitimate information or personal information should be being stored & Complete a task (only source of information for the database) & No illegitimate information or personal information is being stored, only task names and scores, so the DPA cannot be breached anyway & Figure 3.89 \\ \hline
\end{longtable}
\end{center}

\end{landscape}

\subsection{Known Issues}

The only problem remaining is that of the administrator aspect of the system not being possible to create using the time and knowledge I have. In the Python 3.4 shell, every time a window is opened an error to do with the \_raise function pops up, however this does not affect the running of the program in any way and the user will never see this error in the distributed version of the system. Without, this function, the windows will not be displayed, so I cannot simply remove it. Lastly, I will not be able to record total scores from tasks as I still am unable to find a way to pass the appropriate variables through to the appropriate classes.

Otherwise, all of the other problems mentioned in section 3.4.2 have either been solved or replaced with an alternative working solution.

\section{Code Explanations}

\subsection{Difficult Sections}

\textbf{selected\_submit method (ReportWidget Class 4.3.3)}

\begin{python}
def selected_submit(self):
        _count = 0
        data = self.task_box.currentText()
        score_data = self.score_box.currentText()
        report = g_database.get_query(data, score_data)
        for count in range(24):
            self.db.setItem(count, 0, QTableWidgetItem(None))
            self.db.setItem(count, 1, QTableWidgetItem(None))
            self.db.setItem(count, 2, QTableWidgetItem(None))
            self.db.setItem(count, 3, QTableWidgetItem(None))
            self.db.setItem(count, 4, QTableWidgetItem(None))
        for record in report:
            self.db.setItem(_count, 0, QTableWidgetItem(record[0]))
            self.db.setItem(_count, 1, QTableWidgetItem(str(record[1])))
            self.db.setItem(_count, 2, QTableWidgetItem(str(record[2])))
            self.db.setItem(_count, 3, QTableWidgetItem(str(record[3])))
            self.db.setItem(_count, 4, QTableWidgetItem(str(record[4])))
            _count += 1
\end{python}

The part where the database method fetches from the database worked fine here, the problem was displaying the data in the QTableWidget in the report window. Only one record would be displayed, and at first I thought it was because the SQL kept over-writing the previous record, and that the fault was with the insert statements. However it turned out to be to do with the formatting of the fetched information in the QTableWidget; I had to fiddle with counts and tried putting them in different places before all of the data would be displayed, then had to do it again to clear the table with each new query. Eventually the data was all displayed on each row, fixed by an incrementing row count. 

\textbf{Makes the background white (all PyQt classes)}

\begin{python}
pal = QPalette()
        pal.setColor(QPalette.Background, Qt.white)
        self.setAutoFillBackground(True)
        self.setPalette(pal)
\end{python}

This section of simple PyQt code was very hard to come across. I had to research how to change the background colour of a PyQt window on the internet as I had no experience beforehand in this area of PyQt. A very long time was spent trying out similar code which actually only changed the colour of the widgets on the layout rather than the background of the entire window itself. In fact, often everything but the part I wanted to change colour would actually change colour. Eventually, I tried this section of code, and it finally worked, and is useful because I can stick it in parent classes a few times and it will be in all of the subclasses, making the background colour consistent.

\textbf{next\_selected method (ParentHomeworkPage1Class 4.3.18)}

\begin{python}
def next_selected(self):
        cont = False
        while not cont:
            for a in self.answers:
                if a.text() == "":
                    error_message = ErrorMessage8()
                    error_message.show()
                    error_message._raise()
                    cont = False
            cont = True
            if self.allow_cont:
                g_database.insert_data_first(self.task, self.correct_count)
                self.open_page_2()
                self.hide()
            else:
                error_message_2 = ErrorMessage8()
                error_message_2.show()
                error_message_2._raise()
\end{python}

With this method, it was difficult to find the right indentation for the error messages to work with the intended logic, and also change the cont boolean to true. After lots of dry running I managed to get the error messages opening at the right times and the database method to work at the right time.

\textbf{insert\_data\_first method (DatabaseClass 4.3.1)}

\begin{python}
def insert_data_first(self, task, correct_count):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select TaskID from Student where TaskID = '{0}'".format(task))
            info = cursor.fetchall()
            if len(info) != 0:
                sql = "UPDATE Student SET Qone = '{0}' WHERE TaskID = '{1}' AND Qone < '{2}'".format(correct_count, task, correct_count)
            else:
                sql = "insert into Student(TaskID, Qone, Qtwo, Qthree, Qfour) values ('{0}', '{1}', '{2}', '{3}', '{4}')".format(task, correct_count, str(0), str(0), str(0))
            self.execute_sql(sql)
\end{python}

I had a large issue with getting the insert\_data\_second method to be able to update and add new values in a record which already existed with no values in some of the entities. I decided to just add 0 values, as technically this would always be true for the user's score until they completed the second page anyway, and it would prove convenient when adding the update statements to the insert\_data\_second method, which would be able to update over 0 values or existing 1, 2, 3 etc. values. It did however take a long time to find this solution.

\textbf{selected\_mark\_2 method (HomeworkPage2ParentClass (4.3.19)}

\begin{python}
def selected_mark_2(self, attempts_remaining_a):
        self.correct_count_2 = 0
        if self.answer_2.currentText() == "20":
            self.correct_count_2 += 1
            self.mark_2.setText("Correct!")
            self.mark_2.setEnabled(False)
            self.answer_2.setEnabled(False)
        else:
            self.attempts_remaining_a -= 1
            self.mark_2.setText("Mark it|{0}".format(self.attempts_remaining_a))
            if self.attempts_remaining_a == 0:
                self.mark_2.setEnabled(False)
                self.answer_2.setEnabled(False)
            error_message = ErrorMessage5()
            error_message.show()
            error_message._raise()
        return self.attempts_remaining_a, self.correct_count_2
\end{python}

It was quite difficult to find the right indentation for the input widget disabling lines of code here. There were quite a few different things too juggle and maintain logic with this check algorithm - for example, counting the number of attempts remaining and only when that reaches 0 actually disabling the right widgets, and popping the error messages at the right time as well. It took a bit of playing around with the indentation but it eventually worked as intended.

\subsection{Self-created Algorithms}

\textbf{insert\_data\_first method (Database Class 4.3.1)}

\begin{python}
    def insert_data_first(self, task, correct_count):
        with sqlite3.connect(self._db_name) as db:
            cursor = db.cursor()
            cursor.execute("select TaskID from Student where TaskID = '{0}'".format(task))
            info = cursor.fetchall()
            if len(info) != 0:
                sql = "UPDATE Student SET Qone = '{0}' WHERE TaskID = '{1}' AND Qone < '{2}'".format(correct_count, task, correct_count)
            else:
                sql = "insert into Student(TaskID, Qone, Qtwo, Qthree, Qfour) values ('{0}', '{1}', '{2}', '{3}', '{4}')".format(task, correct_count, str(0), str(0), str(0))
            self.execute_sql(sql)
\end{python}



\textbf{insert\_data\_second method (Database Class 4.3.1)}

\begin{python}
    def insert_data_second(self, task, count_2, count_3, count_4):
        with sqlite3.connect(self._db_name) as db:
            sql = "UPDATE Student SET Qtwo = '{0}' WHERE TaskID = '{1}' AND Qtwo < '{2}'".format(count_2, task, count_2)
            self.execute_sql(sql)
            sql_2 = "UPDATE Student SET Qthree = '{0}' WHERE TaskID = '{1}' AND Qthree < '{2}'".format(count_3, task, count_3)
            self.execute_sql(sql_2)
            sql_3 = "UPDATE Student SET Qfour = '{0}' WHERE TaskID = '{1}' AND Qfour < '{2}'".format(count_4, task, count_4)
            self.execute_sql(sql_3)
\end{python}



\textbf{selected\_submit method (Reportwidget 4.3.3)}

\begin{python}
def selected_submit(self):
        _count = 0
        data = self.task_box.currentText()
        score_data = self.score_box.currentText()
        report = g_database.get_query(data, score_data)
        for count in range(24):
            self.db.setItem(count, 0, QTableWidgetItem(None))
            self.db.setItem(count, 1, QTableWidgetItem(None))
            self.db.setItem(count, 2, QTableWidgetItem(None))
            self.db.setItem(count, 3, QTableWidgetItem(None))
            self.db.setItem(count, 4, QTableWidgetItem(None))
        for record in report:
            self.db.setItem(_count, 0, QTableWidgetItem(record[0]))
            self.db.setItem(_count, 1, QTableWidgetItem(str(record[1])))
            self.db.setItem(_count, 2, QTableWidgetItem(str(record[2])))
            self.db.setItem(_count, 3, QTableWidgetItem(str(record[3])))
            self.db.setItem(_count, 4, QTableWidgetItem(str(record[4])))
            _count += 1
\end{python}



\textbf{check\_selected method (ParentLessonPage2 4.3.14)}

\begin{python}
def check_selected(self):
        if self.answer.text() == self.answer_lesson:
            self.answer.setText("{0} Correct".format(self.answer_lesson))
        else:
            self.answer.setText("Incorrect")
        self.answer.setReadOnly(True)
        self.check.setEnabled(False)
\end{python}



\textbf{check\_selected method (HomeworkPage2ParentClass 4.3.19)}

\begin{python}
def check_selected(self):
        self.allow_cont = False
        self.correct_count = 0
        if self.answer_a.text() == self.answer_1_a:
            self.answer_a.setText("{0} Correct".format(self.answer_a.text()))
            self.correct_count += 1
        else:
            self.answer_a.setText("Incorrect")
        if self.answer_b.text() == self.answer_1_b:
            self.answer_b.setText("{0} Correct".format(self.answer_b.text()))
            self.correct_count += 1
        else:
            self.answer_b.setText("Incorrect")
        if self.answer_c.text() == self.answer_1_c:
            self.answer_c.setText("{0} Correct".format(self.answer_c.text()))
            self.correct_count += 1
        else:
            self.answer_c.setText("Incorrect")
        if self.answer_d.text() == self.answer_1_d:
            self.answer_d.setText("{0} Correct".format(self.answer_d.text()))
            self.correct_count += 1
        else:
            self.answer_d.setText("Incorrect")
        if self.answer_e.text() == self.answer_1_e:
            self.answer_e.setText("{0} Correct".format(self.answer_e.text()))
            self.correct_count += 1
        else:
            self.answer_e.setText("Incorrect")
        if self.answer_f.text() == self.answer_1_f:
            self.answer_f.setText("{0} Correct".format(self.answer_f.text()))
            self.correct_count += 1
        else:
            self.answer_f.setText("Incorrect")
        for a in self.answers:
            a.setReadOnly(True)
        self.check.setEnabled(False)
        self.reset.setEnabled(False)
        self.allow_cont = True
\end{python}



\textbf{next\_selected method (ParentHomeworkPage1Class 4.3.18)}

\begin{python}
def next_selected(self):
        cont = False
        while not cont:
            for a in self.answers:
                if a.text() == "":
                    error_message = ErrorMessage8()
                    error_message.show()
                    error_message._raise()
                    cont = False
            cont = True
            if self.allow_cont:
                g_database.insert_data_first(self.task, self.correct_count)
                self.open_page_2()
                self.hide()
            else:
                error_message_2 = ErrorMessage8()
                error_message_2.show()
                error_message_2._raise()
\end{python}



\textbf{reset\_selected method (ParentHomeworkPage1Class 4.3.18)}

\begin{python}
def reset_selected(self):
        self.answer_a.setText(None)
        self.answer_b.setText(None)
        self.answer_c.setText(None)
        self.answer_d.setText(None)
        self.answer_e.setText(None)
        self.answer_f.setText(None)
\end{python}



\textbf{check\_button\_1 method (HomeworkPage2ParentClass 4.3.19)}

\begin{python}
def check_button_1(self, attempts_remaining_c):
        self.correct_count_4 = 0
        if self._button_1.text() == self.answer_question_4:
            self._button_1.setText("Correct")
            self._button_1.setEnabled(False)
            self._button_2.setEnabled(False)
            self._button_3.setEnabled(False)
            self._button_4.setEnabled(False)
            self._button_5.setEnabled(False)
            self._button_6.setEnabled(False)
            self.attempts_button.setText("1 mark!")
            self.correct_count_4 += 1
        else:
            self._button_1.setText("Incorrect")
            self._button_1.setEnabled(False)
            self.attempts_remaining_c -= 1
            self.attempts_button.setText("{0} attempts remaining".format(self.attempts_remaining_c))
            if self.attempts_remaining_c == 0:
                self._button_1.setEnabled(False)
                self._button_2.setEnabled(False)
                self._button_3.setEnabled(False)
                self._button_4.setEnabled(False)
                self._button_5.setEnabled(False)
                self._button_6.setEnabled(False)
                self.attempts_button.setText("No more attempts")
            return self.attempts_remaining_c
\end{python}



\textbf{selected\_mark\_2 method (HomeworkPage2ParentClass 4.3.19)}

\begin{python}
def selected_mark_2(self, attempts_remaining_a):
        self.correct_count_2 = 0
        if self.answer_2.currentText() == "20":
            self.correct_count_2 += 1
            self.mark_2.setText("Correct!")
            self.mark_2.setEnabled(False)
            self.answer_2.setEnabled(False)
        else:
            self.attempts_remaining_a -= 1
            self.mark_2.setText("Mark it|{0}".format(self.attempts_remaining_a))
            if self.attempts_remaining_a == 0:
                self.mark_2.setEnabled(False)
                self.answer_2.setEnabled(False)
            error_message = ErrorMessage5()
            error_message.show()
            error_message._raise()
        return self.attempts_remaining_a, self.correct_count_2
\end{python}



\textbf{selected\_finish method (HomeworkPage2ParentClass 4.3.19)}

\begin{python}
def selected_finish(self):
        if self.attempts_button.text() != "1 mark!" and self.attempts_button.text() != "No more attempts":
            error_message_2 = ErrorMessage8()
            error_message_2.show()
            error_message_2._raise()
        elif self.mark_2.text() != "Correct!" and self.mark_2.text() != "Mark it|0":
            error_message_2 = ErrorMessage8()
            error_message_2.show()
            error_message_2._raise()
        elif self.mark_3.text() != "Correct!" and self.mark_3.text() != "Mark it|0":
            error_message_2 = ErrorMessage8()
            error_message_2.show()
            error_message_2._raise()
        else:
            g_database.insert_data_second(self.task, self.correct_count_2, self.correct_count_3, self.correct_count_4)
            self.parent.close()
\end{python}



\section{Settings}

\section{Acknowledgements}

\section{Code Listing}
\begin{landscape}
%include as many subsections as you have modules
\subsection{Module 1}
%the code below can be uncommented and used to get a code section from a particular file
\begin{comment}
\pythonfile[firstline=5]{./tex/function_programs/print_function.py}
\end{comment}
\end{landscape}

%Class diagrams
%Navigation diagram
